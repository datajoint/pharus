{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "User Documentation", "text": "<p><code>pharus</code> is a generic REST API server backend for DataJoint pipelines built on top of <code>flask</code>, <code>datajoint</code>, and <code>pyjwt</code>.</p> <ul> <li>PyPi Package</li> <li>Docker Image</li> <li>Release</li> <li>Source</li> </ul>"}, {"location": "#installation", "title": "Installation", "text": "<p>If you have not done so already, please install the following dependencies.</p> <ul> <li>Docker</li> <li>Docker Compose</li> </ul>"}, {"location": "#prerequisites", "title": "Prerequisites", "text": "<p>Download the <code>docker-compose-deploy.yaml</code> docker environment from the source located here.</p>"}, {"location": "#running-the-api-server", "title": "Running the API server", "text": "<p>To start the API server, use the command:</p> <pre><code>PHARUS_VERSION=latest docker compose -f docker-compose-deploy.yaml up -d\n</code></pre> <p>To stop the API server, use the command:</p> <pre><code>PHARUS_VERSION=latest docker compose -f docker-compose-deploy.yaml down\n</code></pre>"}, {"location": "#references", "title": "References", "text": "<ul> <li>DataJoint<ul> <li>https://datajoint.io</li> </ul> </li> <li>DataJoint LabBook (a companion frontend)<ul> <li>https://github.com/datajoint/datajoint-labbook</li> </ul> </li> </ul>"}, {"location": "changelog/", "title": "Changelog", "text": "<p>Observes Semantic Versioning standard and Keep a Changelog convention.</p>"}, {"location": "changelog/#0810-2023-11-16", "title": "0.8.10 - 2023-11-16", "text": ""}, {"location": "changelog/#fixed", "title": "Fixed", "text": "<ul> <li>Docs' table cell text color in dark mode #171</li> <li>Bug with <code>/definition</code> route for part tables #170</li> </ul>"}, {"location": "changelog/#089-2023-10-02", "title": "0.8.9 - 2023-10-02", "text": ""}, {"location": "changelog/#added", "title": "Added", "text": "<ul> <li>Throw new errors for invalid schemas and tables #168</li> </ul>"}, {"location": "changelog/#088-2023-09-20", "title": "0.8.8 - 2023-09-20", "text": ""}, {"location": "changelog/#changed", "title": "Changed", "text": "<ul> <li>Pin <code>mkdocs-material</code> version to fix docs build #167</li> </ul>"}, {"location": "changelog/#087-2023-08-08", "title": "0.8.7 - 2023-08-08", "text": ""}, {"location": "changelog/#added_1", "title": "Added", "text": "<ul> <li>Migrate documentation to MkDocs #164</li> <li>Add section in docs for extending pharus #165</li> </ul>"}, {"location": "changelog/#086-2023-05-2", "title": "0.8.6 - 2023-05-2", "text": ""}, {"location": "changelog/#added_2", "title": "Added", "text": "<ul> <li>Added python 3.9 to release matrix #163</li> </ul>"}, {"location": "changelog/#085-2023-04-26", "title": "0.8.5 - 2023-04-26", "text": ""}, {"location": "changelog/#added_3", "title": "Added", "text": "<ul> <li>Part table support for forms #162</li> </ul>"}, {"location": "changelog/#084-2023-04-04", "title": "0.8.4 - 2023-04-04", "text": ""}, {"location": "changelog/#changed_1", "title": "Changed", "text": "<ul> <li>Invalid datetime preset values will now throw a 406 error for <code>/preset</code> routes #160</li> </ul>"}, {"location": "changelog/#083-2023-03-24", "title": "0.8.3 - 2023-03-24", "text": ""}, {"location": "changelog/#changed_2", "title": "Changed", "text": "<ul> <li>Separated table attribute and unique values routes #159</li> </ul>"}, {"location": "changelog/#082-2023-03-23", "title": "0.8.2 - 2023-03-23", "text": ""}, {"location": "changelog/#added_4", "title": "Added", "text": "<ul> <li>Forms now allow you to specify presets using their schemas and tables to avoid collisions #158</li> </ul>"}, {"location": "changelog/#081-2023-03-20", "title": "0.8.1 - 2023-03-20", "text": ""}, {"location": "changelog/#added_5", "title": "Added", "text": "<ul> <li>Api endpoint <code>/spec</code> which returns the spec for the current dynamic routes #156</li> <li>Support for presets in Dynamic forms #157</li> </ul>"}, {"location": "changelog/#bugfix", "title": "Bugfix", "text": "<ul> <li>Added print statement to let user know if their component override has gone through #156</li> </ul>"}, {"location": "changelog/#080-2023-02-06", "title": "0.8.0 - 2023-02-06", "text": ""}, {"location": "changelog/#added_6", "title": "Added", "text": "<ul> <li>Support for new <code>slideshow</code> component #155 #156</li> </ul>"}, {"location": "changelog/#073-2023-01-31", "title": "0.7.3 - 2023-01-31", "text": ""}, {"location": "changelog/#bugfix_1", "title": "Bugfix", "text": "<ul> <li>Fix datetime FPK format for forms (#152) #151</li> </ul>"}, {"location": "changelog/#072-2023-01-13", "title": "0.7.2 - 2023-01-13", "text": ""}, {"location": "changelog/#bugfix_2", "title": "Bugfix", "text": "<ul> <li>Re-add <code>antd-table</code> to regex match for dynamic api gen #150</li> </ul>"}, {"location": "changelog/#071-2023-01-10", "title": "0.7.1 - 2023-01-10", "text": ""}, {"location": "changelog/#bugfix_3", "title": "Bugfix", "text": "<ul> <li>Keyword arguments fixed, host -&gt; databaseAddress and user -&gt; username PR #149</li> </ul>"}, {"location": "changelog/#070-2023-01-05", "title": "0.7.0 - 2023-01-05", "text": ""}, {"location": "changelog/#added_7", "title": "Added", "text": "<ul> <li>Added delete component PR #148</li> </ul>"}, {"location": "changelog/#bugfix_4", "title": "Bugfix", "text": "<ul> <li>Public deploy of dynamic API uses incorrect credential keywords PR #148</li> </ul>"}, {"location": "changelog/#064-2022-12-07", "title": "0.6.4 - 2022-12-07", "text": ""}, {"location": "changelog/#added_8", "title": "Added", "text": "<ul> <li>Support for new <code>antd-table</code> component. Prior <code>table</code> component is deprecated and will be removed in the next major release. PR #128</li> <li>Deprecated warning for <code>table</code> PR #128</li> </ul>"}, {"location": "changelog/#063-2022-11-18", "title": "0.6.3 - 2022-11-18", "text": ""}, {"location": "changelog/#added_9", "title": "Added", "text": "<ul> <li>Added attribute default value to the form component field route response #147</li> </ul>"}, {"location": "changelog/#062-2022-11-10", "title": "0.6.2 - 2022-11-10", "text": ""}, {"location": "changelog/#fixed_1", "title": "Fixed", "text": "<ul> <li>Convert the return of the insert route and normal record routes to valid json #146</li> </ul>"}, {"location": "changelog/#061-2022-11-04", "title": "0.6.1 - 2022-11-04", "text": ""}, {"location": "changelog/#added_10", "title": "Added", "text": "<ul> <li>Add debug traces for standard routes #143</li> <li>Set a manual sleep due to <code>jwt</code> package not validating tokens issued in less than 1 sec #143</li> </ul>"}, {"location": "changelog/#060-2022-11-03", "title": "0.6.0 - 2022-11-03", "text": ""}, {"location": "changelog/#added_11", "title": "Added", "text": "<ul> <li>Allow requests to be thread-safe so that database connections don't cross-pollinate #142</li> <li>Add <code>basicquery</code> and <code>external</code> as options to extend with dynamic spec #142</li> </ul>"}, {"location": "changelog/#056-2022-10-29", "title": "0.5.6 - 2022-10-29", "text": ""}, {"location": "changelog/#added_12", "title": "Added", "text": "<ul> <li>Add option to flush user privileges if root user available using env vars: <code>DJ_HOST</code>, <code>DJ_ROOT_USER</code>, <code>DJ_ROOT_PASS</code> #140</li> </ul>"}, {"location": "changelog/#055-2022-10-26", "title": "0.5.5 - 2022-10-26", "text": ""}, {"location": "changelog/#fixed_2", "title": "Fixed", "text": "<ul> <li>Return <code>id_token</code> on login since it can be useful in OIDC logout flow PR #139</li> </ul>"}, {"location": "changelog/#054-2022-10-20", "title": "0.5.4 - 2022-10-20", "text": ""}, {"location": "changelog/#fixed_3", "title": "Fixed", "text": "<ul> <li>Allow form component table map destination templating PR #138</li> </ul>"}, {"location": "changelog/#053-2022-10-11", "title": "0.5.3 - 2022-10-11", "text": ""}, {"location": "changelog/#fixed_4", "title": "Fixed", "text": "<ul> <li>Flask would add empty body to request method PR #137</li> </ul>"}, {"location": "changelog/#052-2022-10-06", "title": "0.5.2 - 2022-10-06", "text": ""}, {"location": "changelog/#added_13", "title": "Added", "text": "<ul> <li>Create generic component class for custom routes PR #135</li> </ul>"}, {"location": "changelog/#fixed_5", "title": "Fixed", "text": "<ul> <li>Component type check condition to allow form POST route overriding PR #132</li> </ul>"}, {"location": "changelog/#051-2022-09-27", "title": "0.5.1 - 2022-09-27", "text": ""}, {"location": "changelog/#added_14", "title": "Added", "text": "<ul> <li>Schema templating for insert queries using query params PR #131</li> <li>Add support for OIDC login flow PR #130 (#125)</li> </ul>"}, {"location": "changelog/#050-2022-09-21", "title": "0.5.0 - 2022-09-21", "text": ""}, {"location": "changelog/#fixed_6", "title": "Fixed", "text": "<ul> <li>Bugs with returning UUID and NaN values PR #128</li> </ul>"}, {"location": "changelog/#added_15", "title": "Added", "text": "<ul> <li>Support schemas with a <code>-</code> by specifying instead with <code>__</code> in dynamic spec PR #128</li> <li>Support for new <code>antd-table</code> component. Prior <code>table</code> component will be deprecated in the next minor release. PR #128</li> <li>Support for InsertComponent</li> </ul>"}, {"location": "changelog/#041-2022-03-24", "title": "0.4.1 - 2022-03-24", "text": ""}, {"location": "changelog/#fixed_7", "title": "Fixed", "text": "<ul> <li>Bug with otumat version not being tied to the latest PR #119</li> </ul>"}, {"location": "changelog/#040-2022-03-18", "title": "0.4.0 - 2022-03-18", "text": ""}, {"location": "changelog/#fixed_8", "title": "Fixed", "text": "<ul> <li>Bug with <code>order_by</code> not applying from fetch args PR #117</li> </ul>"}, {"location": "changelog/#added_16", "title": "Added", "text": "<ul> <li>Support for new <code>slider</code> and <code>dropdown-query</code> components PR #118</li> <li>Numpy parser for <code>component_interface.py</code> to remove numpy types for json serialization PR #118</li> <li>Support for loginless mode PR #118</li> </ul>"}, {"location": "changelog/#030-2022-01-21", "title": "0.3.0 - 2022-01-21", "text": ""}, {"location": "changelog/#changed_3", "title": "Changed", "text": "<ul> <li>Hot-reload mechanism to use <code>otumat watch</code> PR #116</li> <li>Renamed environment variable defining spec sheet to <code>PHARUS_SPEC_PATH</code> PR #116</li> </ul>"}, {"location": "changelog/#added_17", "title": "Added", "text": "<ul> <li>Autoformatting strategy using <code>black</code> PR #116</li> <li>Support for sci-viz components <code>metadata</code>, <code>image</code>, <code>dynamic grid</code> PR #116</li> <li><code>component interface</code> for users to be able to load their own custom interface for sci-viz PR #116</li> </ul>"}, {"location": "changelog/#fixed_9", "title": "Fixed", "text": "<ul> <li>Various bugs related to datetime PR #116</li> </ul>"}, {"location": "changelog/#023-2021-11-18", "title": "0.2.3 - 2021-11-18", "text": ""}, {"location": "changelog/#added_18", "title": "Added", "text": "<ul> <li>Support for plot component PR #155</li> <li>Fetch argument specification in <code>dj_query</code> PR #155</li> </ul>"}, {"location": "changelog/#022-2021-11-10", "title": "0.2.2 - 2021-11-10", "text": ""}, {"location": "changelog/#fixed_10", "title": "Fixed", "text": "<ul> <li>Optimize dynamic api virtual modules. PR #113</li> </ul>"}, {"location": "changelog/#021-2021-11-08", "title": "0.2.1 - 2021-11-08", "text": ""}, {"location": "changelog/#fixed_11", "title": "Fixed", "text": "<ul> <li>Error with retrieving the module's installation root path. PR #112</li> </ul>"}, {"location": "changelog/#020-2021-11-02", "title": "0.2.0 - 2021-11-02", "text": ""}, {"location": "changelog/#added_19", "title": "Added", "text": "<ul> <li>Dynamic api generation from spec sheet.(#103, #104, #105, #107, #108, #110) PR #106, #109</li> <li><code>dynamic_api_gen.py</code> Python script that generates <code>dynamic_api.py</code>.</li> <li>Add Tests for the new dynamic api.</li> <li><code>server.py</code> now loads the routes generated dynamically from <code>dynamic_api.py</code> when it is present.</li> </ul>"}, {"location": "changelog/#010-2021-03-31", "title": "0.1.0 - 2021-03-31", "text": ""}, {"location": "changelog/#added_20", "title": "Added", "text": "<ul> <li>Local database instance pre-populated with sample data for <code>dev</code> Docker Compose environment. PR #99</li> <li>Capability to insert multiple, update multiple, and delete multiple. PR #99</li> <li>Allow dependency restriction to include secondary attributes from parent table. PR #99</li> </ul>"}, {"location": "changelog/#changed_4", "title": "Changed", "text": "<ul> <li>Update <code>datajoint</code> to newly released <code>0.13.0</code>. PR #97</li> <li>Rename service <code>pharus</code> to <code>pharus-docs</code> in <code>docs</code> Docker Compose environment to allow simulataneous development. PR #99</li> <li>Update NGINX reverse proxy image reference. PR #99</li> <li>Refactored API design to align with common REST resource naming convention. (#38) PR #99</li> <li>Hide classes and methods that are internal and subject to change. PR #99</li> </ul>"}, {"location": "changelog/#removed", "title": "Removed", "text": "<ul> <li><code>InvalidDeleteRequest</code> exception is no longer available as it is now allowed to delete more than 1 record at a time. PR #99</li> </ul>"}, {"location": "changelog/#fixed_12", "title": "Fixed", "text": "<ul> <li><code>uuid</code> types not properly restricted on <code>GET /record</code>, <code>DELETE /record</code>, and <code>GET /dependency</code>. PR #102</li> </ul>"}, {"location": "changelog/#010b2-2021-03-12", "title": "0.1.0b2 - 2021-03-12", "text": ""}, {"location": "changelog/#fixed_13", "title": "Fixed", "text": "<ul> <li>Fixed behavior where using list_table with a nonexistent schema_name creates it instead of returning an error message (#65) PR #63</li> </ul>"}, {"location": "changelog/#changed_5", "title": "Changed", "text": "<ul> <li>Contribution policy to follow directly the general DataJoint Contribution Guideline. (#91) PR #94, #95</li> </ul>"}, {"location": "changelog/#added_21", "title": "Added", "text": "<ul> <li>Issue templates for bug reports and enhancement requests. PR #94, #95</li> <li>Docker environment for documentation build. (#92) PR #94, #95</li> <li>Add Sphinx-based documentation source and fix parsing issues. (#92) PR #94, #95</li> <li>GitHub Actions automation that publishes on release new docs to release and GitHub Pages. (#92) PR #94, #95</li> </ul>"}, {"location": "changelog/#010b0-2021-02-26", "title": "0.1.0b0 - 2021-02-26", "text": ""}, {"location": "changelog/#security", "title": "Security", "text": "<ul> <li>Documentation with detail regarding warning on bearer token. (#83) PR #88</li> </ul>"}, {"location": "changelog/#fixed_14", "title": "Fixed", "text": "<ul> <li>Incorrect virtual module reference of <code>schema_virtual_module</code> in table metadata. (#85) PR #88</li> </ul>"}, {"location": "changelog/#added_22", "title": "Added", "text": "<ul> <li>Docker <code>dev</code> environment that supports hot reloading. PR #79</li> <li>Documentation on setting up environments within <code>docker-compose</code> header. PR #79</li> <li><code>cascade</code> option for <code>/delete_tuple</code> route. (#86) PR #88</li> <li>When delete with <code>cascade=False</code> fails due to foreign key relations, returns a HTTP error code of <code>409 Conflict</code> with a JSON body containing specifics of 1st child. (#86) PR #88</li> </ul>"}, {"location": "changelog/#changed_6", "title": "Changed", "text": "<ul> <li>Replaced <code>DJConnector.snake_to_camel_case</code> usage with <code>datajoint.utils.to_camel_case</code>. PR #88</li> <li>Default behavior for <code>/delete_tuple</code> now deletes without cascading. (#86) PR #88</li> <li>Consolidated <code>pytest</code> fixtures into <code>__init__.py</code> to facilitate reuse. PR #88</li> <li>Modify dependency check to not perform deep check and use accessible fk relations only. (#89) PR #90</li> <li>Update nginx image to pull from datajoint organization. (#80) PR #90</li> </ul>"}, {"location": "changelog/#removed_1", "title": "Removed", "text": "<ul> <li>Docker <code>base</code> environment to simplify dependencies. PR #79</li> </ul>"}, {"location": "changelog/#010a5-2021-02-18", "title": "0.1.0a5 - 2021-02-18", "text": ""}, {"location": "changelog/#added_23", "title": "Added", "text": "<ul> <li>List schemas method.</li> <li>List tables method.</li> <li>Data entry, update, delete, and view operations for DataJoint table tiers: <code>dj.Manual</code>, <code>dj.Lookup</code>.</li> <li>Read table records with proper paging and compounding restrictions (i.e. filters).</li> <li>Read table definition method.</li> <li>Support for DataJoint attribute types: <code>varchar</code>, <code>int</code>, <code>float</code>, <code>datetime</code>, <code>date</code>, <code>time</code>, <code>decimal</code>, <code>uuid</code>.</li> <li>Check dependency utility to determine child table references.</li> </ul>"}, {"location": "dev/", "title": "General Notes", "text": ""}, {"location": "dev/#requirements-for-preferred-setup", "title": "Requirements for Preferred Setup", "text": "<ul> <li>Docker</li> <li>Docker Compose</li> </ul>"}, {"location": "dev/#run-locally-w-docker", "title": "Run Locally w/ Docker", "text": "<ul> <li>Copy the docker environment (i.e. <code>docker-compose-*.yaml</code>) of your   choice corresponding to your usage to <code>docker-compose.yaml</code>. This   file is untracked so feel free to modify as necessary. Idea is to   commit anything generic but system/setup dependent should go on   your version i.e. local UID/GID, etc.</li> </ul> <ul> <li> <p>Check the first header comment which will provide the best   instruction on how to start the service.</p> <ul> <li>Any of the keyword arguments prepended to the <code>docker compose</code>   command can be safely moved into a dedicated <code>.env</code> and read   automatically if they are not evaluated i.e. <code>$(...)</code>. Below is a   brief description of the non-evaluated environment variables:</li> </ul> <pre><code>PY_VER=3.8    # Python version: 3.6|3.7|3.8\nIMAGE=djtest  # Image type:     djbase|djtest|djlab|djlabhub\nDISTRO=alpine # Distribution:   alpine|debian\nAS_SCRIPT=    # If 'TRUE', will not keep container alive but run tests and exit\n</code></pre> </li> </ul> <p>Note</p> <p>Deployment options currently being considered are Docker Compose and Kubernetes.</p>"}, {"location": "dev/#run-locally-w-python", "title": "Run Locally w/ Python", "text": "<ul> <li>Set environment variables for port assignment (<code>PHARUS_PORT</code>,   defaults to 5000) and API route prefix (<code>PHARUS_PREFIX</code> e.g. <code>/api</code>,   defaults to empty string).</li> <li>For development, use CLI command <code>pharus</code>. This method supports   hot-reloading so probably best coupled with <code>pip install -e ...</code>.</li> <li>For production, use   <code>gunicorn --bind 0.0.0.0:${PHARUS_PORT} pharus.server:app</code>.</li> </ul>"}, {"location": "dev/#run-tests-for-development-w-pytest-flake8-black", "title": "Run Tests for Development w/ Pytest, Flake8, Black", "text": "<ul> <li> <p>Set <code>pharus</code> testing environment variables:</p> <pre><code>PKG_DIR=/opt/conda/lib/python3.8/site-packages/pharus # path to pharus installation\nTEST_DB_SERVER=example.com:3306 # testing db server address\nTEST_DB_USER=root # testing db server user (needs DDL privilege)\nTEST_DB_PASS=unsecure # testing db server password\n</code></pre> </li> </ul> <ul> <li>For syntax tests, run   <code>flake8 ${PKG_DIR} --count --select=E9,F63,F7,F82 --show-source --statistics</code></li> </ul> <ul> <li>For pytest integration tests, run   <code>pytest -sv --cov-report term-missing --cov=${PKG_DIR} /main/tests</code></li> </ul> <ul> <li> <p>For style tests, run:</p> <pre><code>black ${PKG_DIR} --check -v --extend-exclude \"^.*dynamic_api.py$\"\nflake8 ${PKG_DIR} --count --max-complexity=20 --max-line-length=94 --statistics --exclude=*dynamic_api.py --ignore=W503\n</code></pre> </li> </ul>"}, {"location": "dev/#extending-pharus-routes", "title": "Extending Pharus Routes", "text": "<p>Pharus' routes can be extended through the spec sheet.</p>"}, {"location": "dev/#guide", "title": "Guide", "text": "<ol> <li> <p>Define the YAML spec sheet. Under <code>SciViz.component_interface.override</code>, in a string block:</p> <ol> <li>Import the <code>type_map</code> and base components from the pharus <code>component.interface</code> module, as well as any other libraries needed.</li> <li> <p>Define a class that extends one of the base components. If extending <code>Component</code>, the rest verb must be manually set.</p> <p>- Within the class, define a <code>dj_query_route</code> method with the functionality of your custom route. Ensure it returns a dictionary.</p> </li> <li> <p>Extend the <code>type_map</code> with a mapping of the name of you want to give to the component to the new class.</p> <p>- The new name can now be used as a type in the <code>components</code> section of the spec.</p> </li> </ol> </li> <li> <p>Inject the spec into pharus</p> <ol> <li>Mount the spec sheet into the container.</li> <li>Set the <code>PHARUS_SPEC_PATH</code> environment variable.</li> </ol> </li> </ol>"}, {"location": "dev/#example", "title": "Example", "text": "<pre><code>SciViz:\nauth:\nmode: database | oidc | none\ncomponent_interface:\noverride: |\n# import `type_map`, the base components to be extended, and any other libraries necessary\nfrom pharus.component_interface import type_map, Component\n\n# define custom class extending a base component\nclass ExampleComponent(Component):\n# set necessary REST verb(s) if extending generic `Component`\nrest_verb=[\"GET\"]\n\n# define `dj_query_route` method that returns some dictionary\ndef dj_query_route(self):\n# some code\nreturn {\"example\": \"example response\"}\n\n# extend the `type_map` with a custom type prefixed with the component type you are extending mapped to the custom component\ntype_map = {\n**type_map, 'external:ExampleType': ExampleComponent\n}\npages:\npage:\nroute: /page\nhidden: true\ngrids:\ngrid:\ntype: fixed\ncomponents:\nexample_component:\nroute: /example_route\ntype: external:ExampleType\n</code></pre> <p>For more information about the spec sheet, visit the SciViz docs.</p>"}, {"location": "dev/#creating-mkdocs-documentation", "title": "Creating MkDocs Documentation", "text": "<p>Run the following command with the appropriate parameters:</p> <pre><code>MODE=\"LIVE|QA|PUSH\" PACKAGE=pharus UPSTREAM_REPO=https://github.com/datajoint/pharus.git HOST_UID=$(id -u) docker compose -f docs/docker-compose.yaml up --build\n</code></pre> <pre><code>MODE=LIVE       # `LIVE` for development, `QA` for testing, `PUSH` for production\nPACKAGE=pharus  # The name of the folder containing the package files: `pharus` if not renamed\nUPSTREAM_REPO=  # The URL of the upstream repository\n</code></pre>"}, {"location": "dev/#references", "title": "References", "text": "<ul> <li>DataJoint<ul> <li>https://datajoint.io</li> </ul> </li> <li>DataJoint LabBook (a companion frontend)<ul> <li>https://github.com/datajoint/datajoint-labbook</li> </ul> </li> <li>Python Tutorial for Flask, Swagger, and Automated docs<ul> <li>https://realpython.com/flask-connexion-rest-api/#reader-comments</li> </ul> </li> </ul>"}, {"location": "api/pharus/error/", "title": "error.py", "text": "<p>Error class library.</p>"}, {"location": "api/pharus/error/#pharus.error.UnsupportedTableType", "title": "<code>UnsupportedTableType</code>", "text": "<p>             Bases: <code>Exception</code></p> <p>Exception raised on unsupported table types.</p> Source code in <code>pharus/error.py</code> <pre><code>class UnsupportedTableType(Exception):\n\"\"\"Exception raised on unsupported table types.\"\"\"\n\n    pass\n</code></pre>"}, {"location": "api/pharus/error/#pharus.error.InvalidRestriction", "title": "<code>InvalidRestriction</code>", "text": "<p>             Bases: <code>Exception</code></p> <p>Exception raised when restrictions result in no records when expected at least one.</p> Source code in <code>pharus/error.py</code> <pre><code>class InvalidRestriction(Exception):\n\"\"\"Exception raised when restrictions result in no records when expected at least one.\"\"\"\n\n    pass\n</code></pre>"}, {"location": "api/pharus/error/#pharus.error.SchemaNotFound", "title": "<code>SchemaNotFound</code>", "text": "<p>             Bases: <code>Exception</code></p> <p>Exception raised when a given schema is not found to exist</p> Source code in <code>pharus/error.py</code> <pre><code>class SchemaNotFound(Exception):\n\"\"\"Exception raised when a given schema is not found to exist\"\"\"\n\n    pass\n</code></pre>"}, {"location": "api/pharus/error/#pharus.error.TableNotFound", "title": "<code>TableNotFound</code>", "text": "<p>             Bases: <code>Exception</code></p> <p>Exception raised when a given table is not found to exist</p> Source code in <code>pharus/error.py</code> <pre><code>class TableNotFound(Exception):\n\"\"\"Exception raised when a given table is not found to exist\"\"\"\n\n    pass\n</code></pre>"}, {"location": "api/pharus/interface/", "title": "interface.py", "text": "<p>Library for interfaces into DataJoint pipelines.</p>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector", "title": "<code>_DJConnector</code>", "text": "<p>Primary connector that communicates with a DataJoint database server.</p> Source code in <code>pharus/interface.py</code> <pre><code>class _DJConnector:\n\"\"\"Primary connector that communicates with a DataJoint database server.\"\"\"\n\n    @staticmethod\n    def _list_schemas(connection: dj.Connection) -&gt; list:\n\"\"\"\n        List all schemas under the database.\n\n        Args:\n            connection (dj.Connection): User's DataJoint connection object\n\n        Returns:\n            List of schemas names in alphabetical order (excludes ``information_schema``,\n            ``sys``, ``performance_schema``, ``mysql``)\n        \"\"\"\n\n        # Attempt to connect return true if successful, false is failed\n        return [\n            row[0]\n            for row in connection.query(\n\"\"\"\n                SELECT SCHEMA_NAME FROM information_schema.schemata\n                WHERE SCHEMA_NAME NOT IN (\n                    \"information_schema\", \"sys\", \"performance_schema\", \"mysql\"\n                )\n                ORDER BY SCHEMA_NAME\n                \"\"\"\n            )\n        ]\n\n    @staticmethod\n    def _list_tables(\n        connection: dj.Connection,\n        schema_name: str,\n    ) -&gt; dict:\n\"\"\"\n        List all tables and their type given a schema.\n\n        Args:\n            connection (dj.Connection): User's DataJoint connection object\n            schema_name (str): Name of schema to list all tables from\n\n        Returns:\n            Contains a key for each table type where values are the respective\n                list of table names\n        \"\"\"\n\n        # Get list of tables names\n        try:\n            schema = dj.Schema(schema_name, create_schema=False, connection=connection)\n        except DataJointError:\n            raise SchemaNotFound(\"Schema does not exist\")\n        tables_name = schema.list_tables()\n        # Dict to store list of table name for each type\n        tables_dict_list = dict(manual=[], lookup=[], computed=[], imported=[], part=[])\n        # Loop through each table name to figure out what type it is and add them to\n        # tables_dict_list\n        for table_name in tables_name:\n            table_type = dj.diagram._get_tier(\n                \"`\" + schema_name + \"`.`\" + table_name + \"`\"\n            ).__name__\n            if table_type == \"Manual\":\n                tables_dict_list[\"manual\"].append(dj.utils.to_camel_case(table_name))\n            elif table_type == \"Lookup\":\n                tables_dict_list[\"lookup\"].append(dj.utils.to_camel_case(table_name))\n            elif table_type == \"Computed\":\n                tables_dict_list[\"computed\"].append(dj.utils.to_camel_case(table_name))\n            elif table_type == \"Imported\":\n                tables_dict_list[\"imported\"].append(dj.utils.to_camel_case(table_name))\n            elif table_type == \"Part\":\n                table_name_parts = table_name.split(\"__\")\n                tables_dict_list[\"part\"].append(\n                    to_camel_case(table_name_parts[-2])\n                    + \".\"\n                    + to_camel_case(table_name_parts[-1])\n                )\n            else:\n                raise UnsupportedTableType(table_name + \" is of unknown table type\")\n        return tables_dict_list\n\n    @staticmethod\n    def _fetch_records(\n        query,\n        restriction: list = [],\n        limit: int = 1000,\n        page: int = 1,\n        order=None,\n        fetch_blobs=False,\n        fetch_args=[],\n    ) -&gt; tuple:\n\"\"\"\n        Get records from the query.\n\n        Args:\n            query: Any datajoint object related to QueryExpression.\n            restriction (optional): Sequence of filters as ``dict`` with ``attributeName``,\n                ``operation``, ``value`` keys defined, defaults to ``[]``.\n            limit (optional): Max number of records to return, defaults to ``1000``.\n            page (optional): Page number to return, defaults to ``1``.\n            order (optional): Sequence to order records, defaults to ``['KEY ASC']``. See\n                :class:`~datajoint.fetch.Fetch` for more info.\n\n        Returns:\n            A tuple containing:\n\n                - Attribute headers\n                - Records in dictionary form\n                - The total number of records that can be paged\n        \"\"\"\n\n        # Get table object from name\n        attributes = query.heading.attributes\n        # Fetch tuples without blobs as dict to be used to create a\n        #   list of tuples for returning\n        query_restricted = query &amp; dj.AndList(\n            [\n                _DJConnector._filter_to_restriction(\n                    f, attributes[f[\"attributeName\"]].type\n                )\n                for f in restriction\n            ]\n        )\n\n        order_by = (\n            fetch_args.pop(\"order_by\") if \"order_by\" in fetch_args else [\"KEY ASC\"]\n        )\n        order_by = order if order else order_by\n\n        limit = fetch_args.pop(\"limit\") if \"limit\" in fetch_args else limit\n\n        if fetch_blobs and not fetch_args:\n            fetch_args = [*query.heading.attributes]\n        elif not fetch_args:\n            fetch_args = query.heading.non_blobs\n        else:\n            attributes = {k: v for k, v in attributes.items() if k in fetch_args}\n        non_blobs_rows = query_restricted.fetch(\n            *fetch_args,\n            as_dict=True,\n            limit=limit,\n            offset=(page - 1) * limit,\n            order_by=order_by,\n        )\n\n        # Buffer list to be return\n        rows = []\n\n        # Looped through each tuple and deal with TEMPORAL types and replacing\n        #   blobs with ==BLOB== for json encoding\n        for non_blobs_row in non_blobs_rows:\n            # Buffer object to store the attributes\n            row = []\n            # Loop through each attributes, append to the tuple_to_return with specific\n            #   modification based on data type\n            for attribute_name, attribute_info in attributes.items():\n                if not attribute_info.is_blob:\n                    if non_blobs_row[attribute_name] is None:\n                        # If it is none then just append None\n                        row.append(None)\n                    elif attribute_info.type == \"date\":\n                        # Date attribute type covert to epoch time\n                        row.append(\n                            (\n                                non_blobs_row[attribute_name]\n                                - datetime.date(1970, 1, 1)\n                            ).days\n                            * DAY\n                        )\n                    elif attribute_info.type == \"time\":\n                        # Time attirbute, return total seconds\n                        row.append(non_blobs_row[attribute_name].total_seconds())\n                    elif re.match(r\"^datetime.*$\", attribute_info.type) or re.match(\n                        r\"timestamp\", attribute_info.type\n                    ):\n                        # Datetime or timestamp, use timestamp to covert to epoch time\n                        row.append(non_blobs_row[attribute_name].timestamp())\n                    elif attribute_info.type[0:7] == \"decimal\":\n                        # Covert decimal to string\n                        row.append(str(non_blobs_row[attribute_name]))\n                    else:\n                        # Normal attribute, just return value with .item to deal with numpy\n                        #   types\n                        if isinstance(non_blobs_row[attribute_name], np.generic):\n                            row.append((non_blobs_row[attribute_name].item()))\n                        else:\n                            row.append(non_blobs_row[attribute_name])\n                else:\n                    # Attribute is blob type thus fill it in string instead\n                    (\n                        row.append(non_blobs_row[attribute_name])\n                        if fetch_blobs\n                        else row.append(\"=BLOB=\")\n                    )\n            # Add the row list to tuples\n            rows.append(row)\n        return list(attributes.keys()), rows, len(query_restricted)\n\n    @staticmethod\n    def _get_attributes(query, include_unique_values=False) -&gt; dict:\n\"\"\"\n        Method to get primary and secondary attributes of a query.\n\n        Args:\n            query: Any datajoint object related to QueryExpression.\n            include_unique_values (optional): Boolean that determines if the unique values are\n                included as part of the returned attributes.\n\n        Returns:\n            A dictionary with keys ``attribute_headers`` and ``attributes`` containing\n                ``primary``, ``secondary``, each of which is a list of tuples specifying:\n\n                - ``attribute_name``\n                - ``nullable``\n                - ``default``\n                - ``autoincrement``\n        \"\"\"\n\n        query_attributes = dict(primary=[], secondary=[])\n        for attribute_name, attribute_info in query.heading.attributes.items():\n            if attribute_info.in_key:\n                query_attributes[\"primary\"].append(\n                    (\n                        attribute_name,\n                        attribute_info.type,\n                        attribute_info.nullable,\n                        attribute_info.default,\n                        attribute_info.autoincrement,\n                        [\n                            dict({\"text\": str(v), \"value\": v})\n                            for (v,) in (dj.U(attribute_name) &amp; query).fetch()\n                        ]\n                        if include_unique_values\n                        else None,\n                    )\n                )\n            else:\n                query_attributes[\"secondary\"].append(\n                    (\n                        attribute_name,\n                        attribute_info.type,\n                        attribute_info.nullable,\n                        attribute_info.default,\n                        attribute_info.autoincrement,\n                        [\n                            dict({\"text\": str(v), \"value\": v})\n                            for (v,) in (dj.U(attribute_name) &amp; query).fetch()\n                        ]\n                        if include_unique_values\n                        else None,\n                    )\n                )\n\n        return dict(\n            attribute_headers=[\"name\", \"type\", \"nullable\", \"default\", \"autoincrement\"],\n            attributes=query_attributes,\n        )\n\n    @staticmethod\n    def _get_table_definition(\n        connection: dj.Connection,\n        schema_name: str,\n        table_name: str,\n    ) -&gt; str:\n\"\"\"\n        Get the table definition.\n\n        Args:\n            connection: User's DataJoint connection object.\n            schema_name: Name of the schema.\n            table_name: Table name under the given schema; must be in camel case.\n\n        Returns:\n            Definition of the table as a string.\n        \"\"\"\n\n        local_values = locals()\n        local_values[schema_name] = dj.VirtualModule(\n            schema_name, schema_name, connection=connection\n        )\n        return _DJConnector._get_table_object(\n            local_values[schema_name], table_name\n        ).describe()\n\n    @staticmethod\n    def _insert_tuple(\n        connection: dj.Connection,\n        schema_name: str,\n        table_name: str,\n        tuple_to_insert: dict,\n    ):\n\"\"\"\n        Insert record as tuple into table.\n\n        Args:\n            connection: User's DataJoint connection object.\n            schema_name: Name of the schema.\n            table_name: Table name under the given schema; must be in camel case.\n            tuple_to_insert: Record to be inserted as a dictionary.\n        \"\"\"\n\n        schema_virtual_module = dj.VirtualModule(\n            schema_name, schema_name, connection=connection\n        )\n        _DJConnector._get_table_object(schema_virtual_module, table_name).insert(\n            tuple_to_insert\n        )\n\n    @staticmethod\n    def _record_dependency(\n        connection: dj.Connection,\n        schema_name: str,\n        table_name: str,\n        restriction: list = [],\n    ) -&gt; list:\n\"\"\"\n        Return summary of dependencies associated with a restricted table. Will only show\n        dependencies that the user has access to.\n\n        Args:\n            connection: User's DataJoint connection object.\n            schema_name: Name of the schema.\n            table_name: Table name under the given schema; must be in camel case.\n            restriction: Sequence of filters as a list of dictionaries with keys\n                \"attributeName\", \"operation\", and \"value\" defined, defaults to [].\n\n        Returns:\n            List of tables that are dependent on specific records.\n        \"\"\"\n\n        virtual_module = dj.VirtualModule(\n            schema_name, schema_name, connection=connection\n        )\n        table = _DJConnector._get_table_object(virtual_module, table_name)\n        attributes = table.heading.attributes\n        # Retrieve dependencies of related to retricted\n        dependencies = [\n            dict(\n                schema=descendant.database,\n                table=descendant.table_name,\n                accessible=True,\n                count=len(\n                    (\n                        table\n                        if descendant.full_table_name == table.full_table_name\n                        else descendant * table\n                    )\n                    &amp; dj.AndList(\n                        [\n                            _DJConnector._filter_to_restriction(\n                                f, attributes[f[\"attributeName\"]].type\n                            )\n                            for f in restriction\n                        ]\n                    )\n                ),\n            )\n            for descendant in table().descendants(as_objects=True)\n        ]\n        return dependencies\n\n    @staticmethod\n    def _update_tuple(\n        connection: dj.Connection,\n        schema_name: str,\n        table_name: str,\n        tuple_to_update: dict,\n    ):\n\"\"\"\n        Update record as a tuple into the table.\n\n        Args:\n            connection: User's DataJoint connection object.\n            schema_name: Name of the schema.\n            table_name: Table name under the given schema; must be in camel case.\n            tuple_to_update: Record to be updated.\n\n        \"\"\"\n\n        schema_virtual_module = dj.VirtualModule(\n            schema_name, schema_name, connection=connection\n        )\n        with connection.transaction:\n            [\n                _DJConnector._get_table_object(\n                    schema_virtual_module, table_name\n                ).update1(t)\n                for t in tuple_to_update\n            ]\n\n    @staticmethod\n    def _delete_records(\n        connection: dj.Connection,\n        schema_name: str,\n        table_name: str,\n        restriction: list = [],\n        cascade: bool = False,\n    ):\n\"\"\"\n        Delete a specific record based on the given restriction.\n\n        Args:\n            connection: User's DataJoint connection object.\n            schema_name: Name of the schema.\n            table_name: Table name under the given schema; must be in camel case.\n            restriction: Sequence of filters as a list of dictionaries with keys\n                         ``attributeName``, ``operation``, and ``value``, defaults to ``[]``.\n            cascade: Allow for cascading delete, defaults to ``False``.\n        \"\"\"\n\n        schema_virtual_module = dj.VirtualModule(\n            schema_name, schema_name, connection=connection\n        )\n\n        # Get table object from name\n        table = _DJConnector._get_table_object(schema_virtual_module, table_name)\n        attributes = table.heading.attributes\n        restrictions = [\n            _DJConnector._filter_to_restriction(f, attributes[f[\"attributeName\"]].type)\n            for f in restriction\n        ]\n\n        # Compute restriction\n        query = table &amp; dj.AndList(restrictions)\n        # Check if there is only 1 tuple to delete otherwise raise error\n        if len(query) == 0:\n            raise InvalidRestriction(\"Nothing to delete\")\n\n        # All check pass thus proceed to delete\n        query.delete(safemode=False) if cascade else query.delete_quick()\n\n    @staticmethod\n    def _get_table_object(\n        schema_virtual_module: VirtualModule, table_name: str\n    ) -&gt; UserTable:\n\"\"\"\n        Helper method for getting the table object based on the provided table name.\n\n        Args:\n            schema_virtual_module: Virtual module for accessing the schema.\n            table_name: Name of the table; for part tables, it should\n                be in the format ``Parent.Part``.\n\n        Returns:\n            DataJoint table object of the specified table.\n        \"\"\"\n\n        # Split the table name by '.' for dealing with part tables\n        table_name_parts = table_name.split(\".\")\n        try:\n            if len(table_name_parts) == 2:\n                return getattr(\n                    getattr(schema_virtual_module, table_name_parts[0]),\n                    table_name_parts[1],\n                )\n            else:\n                return getattr(schema_virtual_module, table_name_parts[0])\n        except AttributeError:\n            raise TableNotFound(\"Table does not exist\")\n\n    @staticmethod\n    def _filter_to_restriction(attribute_filter: dict, attribute_type: str) -&gt; str:\n\"\"\"\n        Converts an attribute filter to a DataJoint-compatible restriction.\n\n        Args:\n            attribute_filter (dict): A filter as a dictionary with keys\n                ``attributeName``, ``operation``, and ``value`` defined.\n                Defaults to an empty dictionary.\n            attribute_type (str): Attribute type.\n\n        Returns:\n            DataJoint-compatible restriction.\n        \"\"\"\n\n        if attribute_filter[\"operation\"] in (\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\"):\n            operation = attribute_filter[\"operation\"]\n        elif attribute_filter[\"value\"] is None:\n            operation = \" IS \" if attribute_filter[\"operation\"] == \"=\" else \" IS NOT \"\n        else:\n            operation = attribute_filter[\"operation\"]\n\n        if (\n            isinstance(attribute_filter[\"value\"], str)\n            and not attribute_filter[\"value\"].isnumeric()\n        ):\n            value = (\n                f\"X'{attribute_filter['value'].replace('-', '')}'\"\n                if attribute_type == \"uuid\"\n                else f\"'{attribute_filter['value']}'\"\n            )\n        else:\n            value = (\n                \"NULL\"\n                if attribute_filter[\"value\"] is None\n                else attribute_filter[\"value\"]\n            )\n        return f\"{attribute_filter['attributeName']}{operation}{value}\"\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._list_schemas", "title": "<code>_list_schemas(connection)</code>  <code>staticmethod</code>", "text": "<p>List all schemas under the database.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of schemas names in alphabetical order (excludes <code>information_schema</code>,</p> <code>list</code> <p><code>sys</code>, <code>performance_schema</code>, <code>mysql</code>)</p> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _list_schemas(connection: dj.Connection) -&gt; list:\n\"\"\"\n    List all schemas under the database.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n\n    Returns:\n        List of schemas names in alphabetical order (excludes ``information_schema``,\n        ``sys``, ``performance_schema``, ``mysql``)\n    \"\"\"\n\n    # Attempt to connect return true if successful, false is failed\n    return [\n        row[0]\n        for row in connection.query(\n\"\"\"\n            SELECT SCHEMA_NAME FROM information_schema.schemata\n            WHERE SCHEMA_NAME NOT IN (\n                \"information_schema\", \"sys\", \"performance_schema\", \"mysql\"\n            )\n            ORDER BY SCHEMA_NAME\n            \"\"\"\n        )\n    ]\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._list_tables", "title": "<code>_list_tables(connection, schema_name)</code>  <code>staticmethod</code>", "text": "<p>List all tables and their type given a schema.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <code>schema_name</code> <code>str</code> <p>Name of schema to list all tables from</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Contains a key for each table type where values are the respective list of table names</p> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _list_tables(\n    connection: dj.Connection,\n    schema_name: str,\n) -&gt; dict:\n\"\"\"\n    List all tables and their type given a schema.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n        schema_name (str): Name of schema to list all tables from\n\n    Returns:\n        Contains a key for each table type where values are the respective\n            list of table names\n    \"\"\"\n\n    # Get list of tables names\n    try:\n        schema = dj.Schema(schema_name, create_schema=False, connection=connection)\n    except DataJointError:\n        raise SchemaNotFound(\"Schema does not exist\")\n    tables_name = schema.list_tables()\n    # Dict to store list of table name for each type\n    tables_dict_list = dict(manual=[], lookup=[], computed=[], imported=[], part=[])\n    # Loop through each table name to figure out what type it is and add them to\n    # tables_dict_list\n    for table_name in tables_name:\n        table_type = dj.diagram._get_tier(\n            \"`\" + schema_name + \"`.`\" + table_name + \"`\"\n        ).__name__\n        if table_type == \"Manual\":\n            tables_dict_list[\"manual\"].append(dj.utils.to_camel_case(table_name))\n        elif table_type == \"Lookup\":\n            tables_dict_list[\"lookup\"].append(dj.utils.to_camel_case(table_name))\n        elif table_type == \"Computed\":\n            tables_dict_list[\"computed\"].append(dj.utils.to_camel_case(table_name))\n        elif table_type == \"Imported\":\n            tables_dict_list[\"imported\"].append(dj.utils.to_camel_case(table_name))\n        elif table_type == \"Part\":\n            table_name_parts = table_name.split(\"__\")\n            tables_dict_list[\"part\"].append(\n                to_camel_case(table_name_parts[-2])\n                + \".\"\n                + to_camel_case(table_name_parts[-1])\n            )\n        else:\n            raise UnsupportedTableType(table_name + \" is of unknown table type\")\n    return tables_dict_list\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._fetch_records", "title": "<code>_fetch_records(query, restriction=[], limit=1000, page=1, order=None, fetch_blobs=False, fetch_args=[])</code>  <code>staticmethod</code>", "text": "<p>Get records from the query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <p>Any datajoint object related to QueryExpression.</p> required <code>restriction</code> <code>optional</code> <p>Sequence of filters as <code>dict</code> with <code>attributeName</code>, <code>operation</code>, <code>value</code> keys defined, defaults to <code>[]</code>.</p> <code>[]</code> <code>limit</code> <code>optional</code> <p>Max number of records to return, defaults to <code>1000</code>.</p> <code>1000</code> <code>page</code> <code>optional</code> <p>Page number to return, defaults to <code>1</code>.</p> <code>1</code> <code>order</code> <code>optional</code> <p>Sequence to order records, defaults to <code>['KEY ASC']</code>. See :class:<code>~datajoint.fetch.Fetch</code> for more info.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:</p> <ul> <li>Attribute headers</li> <li>Records in dictionary form</li> <li>The total number of records that can be paged</li> </ul> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _fetch_records(\n    query,\n    restriction: list = [],\n    limit: int = 1000,\n    page: int = 1,\n    order=None,\n    fetch_blobs=False,\n    fetch_args=[],\n) -&gt; tuple:\n\"\"\"\n    Get records from the query.\n\n    Args:\n        query: Any datajoint object related to QueryExpression.\n        restriction (optional): Sequence of filters as ``dict`` with ``attributeName``,\n            ``operation``, ``value`` keys defined, defaults to ``[]``.\n        limit (optional): Max number of records to return, defaults to ``1000``.\n        page (optional): Page number to return, defaults to ``1``.\n        order (optional): Sequence to order records, defaults to ``['KEY ASC']``. See\n            :class:`~datajoint.fetch.Fetch` for more info.\n\n    Returns:\n        A tuple containing:\n\n            - Attribute headers\n            - Records in dictionary form\n            - The total number of records that can be paged\n    \"\"\"\n\n    # Get table object from name\n    attributes = query.heading.attributes\n    # Fetch tuples without blobs as dict to be used to create a\n    #   list of tuples for returning\n    query_restricted = query &amp; dj.AndList(\n        [\n            _DJConnector._filter_to_restriction(\n                f, attributes[f[\"attributeName\"]].type\n            )\n            for f in restriction\n        ]\n    )\n\n    order_by = (\n        fetch_args.pop(\"order_by\") if \"order_by\" in fetch_args else [\"KEY ASC\"]\n    )\n    order_by = order if order else order_by\n\n    limit = fetch_args.pop(\"limit\") if \"limit\" in fetch_args else limit\n\n    if fetch_blobs and not fetch_args:\n        fetch_args = [*query.heading.attributes]\n    elif not fetch_args:\n        fetch_args = query.heading.non_blobs\n    else:\n        attributes = {k: v for k, v in attributes.items() if k in fetch_args}\n    non_blobs_rows = query_restricted.fetch(\n        *fetch_args,\n        as_dict=True,\n        limit=limit,\n        offset=(page - 1) * limit,\n        order_by=order_by,\n    )\n\n    # Buffer list to be return\n    rows = []\n\n    # Looped through each tuple and deal with TEMPORAL types and replacing\n    #   blobs with ==BLOB== for json encoding\n    for non_blobs_row in non_blobs_rows:\n        # Buffer object to store the attributes\n        row = []\n        # Loop through each attributes, append to the tuple_to_return with specific\n        #   modification based on data type\n        for attribute_name, attribute_info in attributes.items():\n            if not attribute_info.is_blob:\n                if non_blobs_row[attribute_name] is None:\n                    # If it is none then just append None\n                    row.append(None)\n                elif attribute_info.type == \"date\":\n                    # Date attribute type covert to epoch time\n                    row.append(\n                        (\n                            non_blobs_row[attribute_name]\n                            - datetime.date(1970, 1, 1)\n                        ).days\n                        * DAY\n                    )\n                elif attribute_info.type == \"time\":\n                    # Time attirbute, return total seconds\n                    row.append(non_blobs_row[attribute_name].total_seconds())\n                elif re.match(r\"^datetime.*$\", attribute_info.type) or re.match(\n                    r\"timestamp\", attribute_info.type\n                ):\n                    # Datetime or timestamp, use timestamp to covert to epoch time\n                    row.append(non_blobs_row[attribute_name].timestamp())\n                elif attribute_info.type[0:7] == \"decimal\":\n                    # Covert decimal to string\n                    row.append(str(non_blobs_row[attribute_name]))\n                else:\n                    # Normal attribute, just return value with .item to deal with numpy\n                    #   types\n                    if isinstance(non_blobs_row[attribute_name], np.generic):\n                        row.append((non_blobs_row[attribute_name].item()))\n                    else:\n                        row.append(non_blobs_row[attribute_name])\n            else:\n                # Attribute is blob type thus fill it in string instead\n                (\n                    row.append(non_blobs_row[attribute_name])\n                    if fetch_blobs\n                    else row.append(\"=BLOB=\")\n                )\n        # Add the row list to tuples\n        rows.append(row)\n    return list(attributes.keys()), rows, len(query_restricted)\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._get_attributes", "title": "<code>_get_attributes(query, include_unique_values=False)</code>  <code>staticmethod</code>", "text": "<p>Method to get primary and secondary attributes of a query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <p>Any datajoint object related to QueryExpression.</p> required <code>include_unique_values</code> <code>optional</code> <p>Boolean that determines if the unique values are included as part of the returned attributes.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with keys <code>attribute_headers</code> and <code>attributes</code> containing <code>primary</code>, <code>secondary</code>, each of which is a list of tuples specifying:</p> <ul> <li><code>attribute_name</code></li> <li><code>nullable</code></li> <li><code>default</code></li> <li><code>autoincrement</code></li> </ul> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _get_attributes(query, include_unique_values=False) -&gt; dict:\n\"\"\"\n    Method to get primary and secondary attributes of a query.\n\n    Args:\n        query: Any datajoint object related to QueryExpression.\n        include_unique_values (optional): Boolean that determines if the unique values are\n            included as part of the returned attributes.\n\n    Returns:\n        A dictionary with keys ``attribute_headers`` and ``attributes`` containing\n            ``primary``, ``secondary``, each of which is a list of tuples specifying:\n\n            - ``attribute_name``\n            - ``nullable``\n            - ``default``\n            - ``autoincrement``\n    \"\"\"\n\n    query_attributes = dict(primary=[], secondary=[])\n    for attribute_name, attribute_info in query.heading.attributes.items():\n        if attribute_info.in_key:\n            query_attributes[\"primary\"].append(\n                (\n                    attribute_name,\n                    attribute_info.type,\n                    attribute_info.nullable,\n                    attribute_info.default,\n                    attribute_info.autoincrement,\n                    [\n                        dict({\"text\": str(v), \"value\": v})\n                        for (v,) in (dj.U(attribute_name) &amp; query).fetch()\n                    ]\n                    if include_unique_values\n                    else None,\n                )\n            )\n        else:\n            query_attributes[\"secondary\"].append(\n                (\n                    attribute_name,\n                    attribute_info.type,\n                    attribute_info.nullable,\n                    attribute_info.default,\n                    attribute_info.autoincrement,\n                    [\n                        dict({\"text\": str(v), \"value\": v})\n                        for (v,) in (dj.U(attribute_name) &amp; query).fetch()\n                    ]\n                    if include_unique_values\n                    else None,\n                )\n            )\n\n    return dict(\n        attribute_headers=[\"name\", \"type\", \"nullable\", \"default\", \"autoincrement\"],\n        attributes=query_attributes,\n    )\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._get_table_definition", "title": "<code>_get_table_definition(connection, schema_name, table_name)</code>  <code>staticmethod</code>", "text": "<p>Get the table definition.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object.</p> required <code>schema_name</code> <code>str</code> <p>Name of the schema.</p> required <code>table_name</code> <code>str</code> <p>Table name under the given schema; must be in camel case.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Definition of the table as a string.</p> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _get_table_definition(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n) -&gt; str:\n\"\"\"\n    Get the table definition.\n\n    Args:\n        connection: User's DataJoint connection object.\n        schema_name: Name of the schema.\n        table_name: Table name under the given schema; must be in camel case.\n\n    Returns:\n        Definition of the table as a string.\n    \"\"\"\n\n    local_values = locals()\n    local_values[schema_name] = dj.VirtualModule(\n        schema_name, schema_name, connection=connection\n    )\n    return _DJConnector._get_table_object(\n        local_values[schema_name], table_name\n    ).describe()\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._insert_tuple", "title": "<code>_insert_tuple(connection, schema_name, table_name, tuple_to_insert)</code>  <code>staticmethod</code>", "text": "<p>Insert record as tuple into table.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object.</p> required <code>schema_name</code> <code>str</code> <p>Name of the schema.</p> required <code>table_name</code> <code>str</code> <p>Table name under the given schema; must be in camel case.</p> required <code>tuple_to_insert</code> <code>dict</code> <p>Record to be inserted as a dictionary.</p> required Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _insert_tuple(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n    tuple_to_insert: dict,\n):\n\"\"\"\n    Insert record as tuple into table.\n\n    Args:\n        connection: User's DataJoint connection object.\n        schema_name: Name of the schema.\n        table_name: Table name under the given schema; must be in camel case.\n        tuple_to_insert: Record to be inserted as a dictionary.\n    \"\"\"\n\n    schema_virtual_module = dj.VirtualModule(\n        schema_name, schema_name, connection=connection\n    )\n    _DJConnector._get_table_object(schema_virtual_module, table_name).insert(\n        tuple_to_insert\n    )\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._record_dependency", "title": "<code>_record_dependency(connection, schema_name, table_name, restriction=[])</code>  <code>staticmethod</code>", "text": "<p>Return summary of dependencies associated with a restricted table. Will only show dependencies that the user has access to.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object.</p> required <code>schema_name</code> <code>str</code> <p>Name of the schema.</p> required <code>table_name</code> <code>str</code> <p>Table name under the given schema; must be in camel case.</p> required <code>restriction</code> <code>list</code> <p>Sequence of filters as a list of dictionaries with keys \"attributeName\", \"operation\", and \"value\" defined, defaults to [].</p> <code>[]</code> <p>Returns:</p> Type Description <code>list</code> <p>List of tables that are dependent on specific records.</p> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _record_dependency(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n    restriction: list = [],\n) -&gt; list:\n\"\"\"\n    Return summary of dependencies associated with a restricted table. Will only show\n    dependencies that the user has access to.\n\n    Args:\n        connection: User's DataJoint connection object.\n        schema_name: Name of the schema.\n        table_name: Table name under the given schema; must be in camel case.\n        restriction: Sequence of filters as a list of dictionaries with keys\n            \"attributeName\", \"operation\", and \"value\" defined, defaults to [].\n\n    Returns:\n        List of tables that are dependent on specific records.\n    \"\"\"\n\n    virtual_module = dj.VirtualModule(\n        schema_name, schema_name, connection=connection\n    )\n    table = _DJConnector._get_table_object(virtual_module, table_name)\n    attributes = table.heading.attributes\n    # Retrieve dependencies of related to retricted\n    dependencies = [\n        dict(\n            schema=descendant.database,\n            table=descendant.table_name,\n            accessible=True,\n            count=len(\n                (\n                    table\n                    if descendant.full_table_name == table.full_table_name\n                    else descendant * table\n                )\n                &amp; dj.AndList(\n                    [\n                        _DJConnector._filter_to_restriction(\n                            f, attributes[f[\"attributeName\"]].type\n                        )\n                        for f in restriction\n                    ]\n                )\n            ),\n        )\n        for descendant in table().descendants(as_objects=True)\n    ]\n    return dependencies\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._update_tuple", "title": "<code>_update_tuple(connection, schema_name, table_name, tuple_to_update)</code>  <code>staticmethod</code>", "text": "<p>Update record as a tuple into the table.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object.</p> required <code>schema_name</code> <code>str</code> <p>Name of the schema.</p> required <code>table_name</code> <code>str</code> <p>Table name under the given schema; must be in camel case.</p> required <code>tuple_to_update</code> <code>dict</code> <p>Record to be updated.</p> required Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _update_tuple(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n    tuple_to_update: dict,\n):\n\"\"\"\n    Update record as a tuple into the table.\n\n    Args:\n        connection: User's DataJoint connection object.\n        schema_name: Name of the schema.\n        table_name: Table name under the given schema; must be in camel case.\n        tuple_to_update: Record to be updated.\n\n    \"\"\"\n\n    schema_virtual_module = dj.VirtualModule(\n        schema_name, schema_name, connection=connection\n    )\n    with connection.transaction:\n        [\n            _DJConnector._get_table_object(\n                schema_virtual_module, table_name\n            ).update1(t)\n            for t in tuple_to_update\n        ]\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._delete_records", "title": "<code>_delete_records(connection, schema_name, table_name, restriction=[], cascade=False)</code>  <code>staticmethod</code>", "text": "<p>Delete a specific record based on the given restriction.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object.</p> required <code>schema_name</code> <code>str</code> <p>Name of the schema.</p> required <code>table_name</code> <code>str</code> <p>Table name under the given schema; must be in camel case.</p> required <code>restriction</code> <code>list</code> <p>Sequence of filters as a list of dictionaries with keys          <code>attributeName</code>, <code>operation</code>, and <code>value</code>, defaults to <code>[]</code>.</p> <code>[]</code> <code>cascade</code> <code>bool</code> <p>Allow for cascading delete, defaults to <code>False</code>.</p> <code>False</code> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _delete_records(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n    restriction: list = [],\n    cascade: bool = False,\n):\n\"\"\"\n    Delete a specific record based on the given restriction.\n\n    Args:\n        connection: User's DataJoint connection object.\n        schema_name: Name of the schema.\n        table_name: Table name under the given schema; must be in camel case.\n        restriction: Sequence of filters as a list of dictionaries with keys\n                     ``attributeName``, ``operation``, and ``value``, defaults to ``[]``.\n        cascade: Allow for cascading delete, defaults to ``False``.\n    \"\"\"\n\n    schema_virtual_module = dj.VirtualModule(\n        schema_name, schema_name, connection=connection\n    )\n\n    # Get table object from name\n    table = _DJConnector._get_table_object(schema_virtual_module, table_name)\n    attributes = table.heading.attributes\n    restrictions = [\n        _DJConnector._filter_to_restriction(f, attributes[f[\"attributeName\"]].type)\n        for f in restriction\n    ]\n\n    # Compute restriction\n    query = table &amp; dj.AndList(restrictions)\n    # Check if there is only 1 tuple to delete otherwise raise error\n    if len(query) == 0:\n        raise InvalidRestriction(\"Nothing to delete\")\n\n    # All check pass thus proceed to delete\n    query.delete(safemode=False) if cascade else query.delete_quick()\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._get_table_object", "title": "<code>_get_table_object(schema_virtual_module, table_name)</code>  <code>staticmethod</code>", "text": "<p>Helper method for getting the table object based on the provided table name.</p> <p>Parameters:</p> Name Type Description Default <code>schema_virtual_module</code> <code>VirtualModule</code> <p>Virtual module for accessing the schema.</p> required <code>table_name</code> <code>str</code> <p>Name of the table; for part tables, it should be in the format <code>Parent.Part</code>.</p> required <p>Returns:</p> Type Description <code>UserTable</code> <p>DataJoint table object of the specified table.</p> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _get_table_object(\n    schema_virtual_module: VirtualModule, table_name: str\n) -&gt; UserTable:\n\"\"\"\n    Helper method for getting the table object based on the provided table name.\n\n    Args:\n        schema_virtual_module: Virtual module for accessing the schema.\n        table_name: Name of the table; for part tables, it should\n            be in the format ``Parent.Part``.\n\n    Returns:\n        DataJoint table object of the specified table.\n    \"\"\"\n\n    # Split the table name by '.' for dealing with part tables\n    table_name_parts = table_name.split(\".\")\n    try:\n        if len(table_name_parts) == 2:\n            return getattr(\n                getattr(schema_virtual_module, table_name_parts[0]),\n                table_name_parts[1],\n            )\n        else:\n            return getattr(schema_virtual_module, table_name_parts[0])\n    except AttributeError:\n        raise TableNotFound(\"Table does not exist\")\n</code></pre>"}, {"location": "api/pharus/interface/#pharus.interface._DJConnector._filter_to_restriction", "title": "<code>_filter_to_restriction(attribute_filter, attribute_type)</code>  <code>staticmethod</code>", "text": "<p>Converts an attribute filter to a DataJoint-compatible restriction.</p> <p>Parameters:</p> Name Type Description Default <code>attribute_filter</code> <code>dict</code> <p>A filter as a dictionary with keys <code>attributeName</code>, <code>operation</code>, and <code>value</code> defined. Defaults to an empty dictionary.</p> required <code>attribute_type</code> <code>str</code> <p>Attribute type.</p> required <p>Returns:</p> Type Description <code>str</code> <p>DataJoint-compatible restriction.</p> Source code in <code>pharus/interface.py</code> <pre><code>@staticmethod\ndef _filter_to_restriction(attribute_filter: dict, attribute_type: str) -&gt; str:\n\"\"\"\n    Converts an attribute filter to a DataJoint-compatible restriction.\n\n    Args:\n        attribute_filter (dict): A filter as a dictionary with keys\n            ``attributeName``, ``operation``, and ``value`` defined.\n            Defaults to an empty dictionary.\n        attribute_type (str): Attribute type.\n\n    Returns:\n        DataJoint-compatible restriction.\n    \"\"\"\n\n    if attribute_filter[\"operation\"] in (\"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\"):\n        operation = attribute_filter[\"operation\"]\n    elif attribute_filter[\"value\"] is None:\n        operation = \" IS \" if attribute_filter[\"operation\"] == \"=\" else \" IS NOT \"\n    else:\n        operation = attribute_filter[\"operation\"]\n\n    if (\n        isinstance(attribute_filter[\"value\"], str)\n        and not attribute_filter[\"value\"].isnumeric()\n    ):\n        value = (\n            f\"X'{attribute_filter['value'].replace('-', '')}'\"\n            if attribute_type == \"uuid\"\n            else f\"'{attribute_filter['value']}'\"\n        )\n    else:\n        value = (\n            \"NULL\"\n            if attribute_filter[\"value\"] is None\n            else attribute_filter[\"value\"]\n        )\n    return f\"{attribute_filter['attributeName']}{operation}{value}\"\n</code></pre>"}, {"location": "api/pharus/server/", "title": "server.py", "text": "<p>Exposed REST API.</p>"}, {"location": "api/pharus/server/#pharus.server.protected_route", "title": "<code>protected_route(function)</code>", "text": "<p>Protected route function decorator which authenticates requests.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable</code> <p>Function to decorate, typically routes</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Function's output if JWT authetication is successful, otherwise return error message</p> Source code in <code>pharus/server.py</code> <pre><code>def protected_route(function: Callable) -&gt; Callable:\n\"\"\"\n    Protected route function decorator which authenticates requests.\n\n    Args:\n        function: Function to decorate, typically routes\n\n    Returns:\n        Function's output if JWT authetication is successful, otherwise return error message\n    \"\"\"\n\n    @wraps(function)\n    def wrapper(**kwargs):\n        try:\n            if \"database_host\" in request.args:\n                encoded_jwt = request.headers.get(\"Authorization\").split()[1]\n                connect_creds = {\n                    \"databaseAddress\": request.args[\"database_host\"],\n                    \"username\": jwt.decode(\n                        encoded_jwt,\n                        crypto_serialization.load_der_public_key(\n                            b64decode(environ.get(\"PHARUS_OIDC_PUBLIC_KEY\").encode())\n                        ),\n                        algorithms=\"RS256\",\n                        options=dict(verify_aud=False),\n                    )[environ.get(\"PHARUS_OIDC_SUBJECT_KEY\")],\n                    \"password\": encoded_jwt,\n                }\n            else:\n                connect_creds = jwt.decode(\n                    request.headers.get(\"Authorization\").split()[1],\n                    environ[\"PHARUS_PUBLIC_KEY\"],\n                    algorithms=\"RS256\",\n                )\n            connection = dj.Connection(\n                host=connect_creds[\"databaseAddress\"],\n                user=connect_creds[\"username\"],\n                password=connect_creds[\"password\"],\n            )\n            return function(connection, **kwargs)\n        except Exception as e:\n            return str(e), 401\n\n    wrapper.__name__ = function.__name__\n    return wrapper\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.api_version", "title": "<code>api_version()</code>", "text": "<p>Handler for <code>/version</code> route.</p> <p>Returns:</p> Type Description <code>str</code> <p>API version</p>"}, {"location": "api/pharus/server/#pharus.server.api_version--get-version", "title": "GET /version", "text": "<p>Route to check server health returning the API version.</p>"}, {"location": "api/pharus/server/#pharus.server.api_version--example-request", "title": "Example request:", "text": "<pre><code>GET /version HTTP/1.1\nHost: fakeservices.datajoint.io\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.api_version--example-response", "title": "Example response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: application/json\n\n{\n\"version\": \"0.8.10\"\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.api_version--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(f\"{environ.get('PHARUS_PREFIX', '')}/version\", methods=[\"GET\"])\ndef api_version() -&gt; str:\n\"\"\"\n    Handler for ``/version`` route.\n\n    Returns:\n        API version\n\n    ## GET /version\n\n    Route to check server health returning the API version.\n\n    ### Example request:\n\n    ```http\n    GET /version HTTP/1.1\n    Host: fakeservices.datajoint.io\n    ```\n\n    ### Example response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"version\": \"0.8.10\"\n    }\n    ```\n\n    #### Status Codes\n    * 200 OK: No error.\n    \"\"\"\n    if request.method in {\"GET\", \"HEAD\"}:\n        return dict(version=version)\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.login", "title": "<code>login()</code>", "text": "<p>Handler for <code>/login</code> route.</p> Warning <p>Currently, this implementation exposes user database credentials as plain text in POST body once and stores it within a bearer token as Base64 encoded for subsequent requests. That is how the server is able to submit queries on user's behalf. Due to this, it is required that remote hosts expose the server only under HTTPS to ensure end-to-end encryption. Sending passwords in plain text over HTTPS in POST request body is common and utilized by companies such as GitHub (2021) and Chase Bank (2021). On server side, there is no caching, logging, or storage of received passwords or tokens and thus available only briefly in memory. This means the primary vulnerable point is client side. Users should be responsible with their passwords and bearer tokens treating them as one-in-the-same. Be aware that if your client system happens to be compromised, a bad actor could monitor your outgoing network requests and capture/log your credentials. However, in such a terrible scenario, a bad actor would not only collect credentials for your DataJoint database but also other sites such as github.com, chase.com, etc. Please be responsible and vigilant with credentials and tokens on client side systems. Improvements to the above strategy is currently being tracked in https://github.com/datajoint/pharus/issues/82.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Function output is an encoded JWT if successful, otherwise return error message</p>"}, {"location": "api/pharus/server/#pharus.server.login--post-login", "title": "POST /login", "text": "<p>Route to generate an authentication token.</p>"}, {"location": "api/pharus/server/#pharus.server.login--example-request", "title": "Example request:", "text": "<pre><code>POST /login HTTP/1.1\nHost: fakeservices.datajoint.io\nAccept: application/json\n\n{\n    \"databaseAddress\": \"tutorial-db.datajoint.io\",\n    \"username\": \"user1\",\n    \"password\": \"password1\"\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.login--example-successful-response", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: application/json\n\n{\n\"jwt\": \"&lt;token&gt;\"\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.login--example-unexpected-response", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could not\n    understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.login--response-headers", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain, application/json</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.login--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered.     Returns the error message as a string.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(f\"{environ.get('PHARUS_PREFIX', '')}/login\", methods=[\"POST\"])\ndef login() -&gt; dict:\n\"\"\"\n    Handler for ``/login`` route.\n\n    Warning:\n        Currently, this implementation exposes user database credentials as plain text in\n        POST body once and stores it within a bearer token as Base64 encoded for\n        subsequent requests. That is how the server is able to submit queries on user's\n        behalf. Due to this, it is required that remote hosts expose the server only\n        under HTTPS to ensure end-to-end encryption. Sending passwords in plain text over\n        HTTPS in POST request body is common and utilized by companies such as GitHub\n        (2021) and Chase Bank (2021). On server side, there is no caching, logging, or\n        storage of received passwords or tokens and thus available only briefly in\n        memory. This means the primary vulnerable point is client side. Users should be\n        responsible with their passwords and bearer tokens treating them as\n        one-in-the-same. Be aware that if your client system happens to be compromised,\n        a bad actor could monitor your outgoing network requests and capture/log your\n        credentials. However, in such a terrible scenario, a bad actor would not only\n        collect credentials for your DataJoint database but also other sites such as\n        github.com, chase.com, etc. Please be responsible and vigilant with credentials\n        and tokens on client side systems. Improvements to the above strategy is\n        currently being tracked in https://github.com/datajoint/pharus/issues/82.\n\n    Returns:\n        Function output is an encoded JWT if successful, otherwise return error message\n\n    ## POST /login\n\n    Route to generate an authentication token.\n\n    ### Example request:\n\n    ```http\n    POST /login HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Accept: application/json\n\n    {\n        \"databaseAddress\": \"tutorial-db.datajoint.io\",\n        \"username\": \"user1\",\n        \"password\": \"password1\"\n    }\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"jwt\": \"&lt;token&gt;\"\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could not\n        understand.\n    ```\n\n    #### Response Headers\n    * Content-Type: text/plain, application/json\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered.\n        Returns the error message as a string.\n    \"\"\"\n    if request.method == \"POST\":\n        # Try to login in with the database connection info, if true then create jwt key\n        try:\n            if \"database_host\" in request.args:\n                # Oidc token exchange\n\n                body = {\n                    \"grant_type\": \"authorization_code\",\n                    \"code\": request.args[\"code\"],\n                    \"code_verifier\": environ.get(\"PHARUS_OIDC_CODE_VERIFIER\"),\n                    \"client_id\": environ.get(\"PHARUS_OIDC_CLIENT_ID\"),\n                    \"redirect_uri\": environ.get(\"PHARUS_OIDC_REDIRECT_URI\"),\n                }\n                headers = {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                }\n                auth = HTTPBasicAuth(\n                    environ.get(\"PHARUS_OIDC_CLIENT_ID\"),\n                    environ.get(\"PHARUS_OIDC_CLIENT_SECRET\"),\n                )\n                result = requests.post(\n                    environ.get(\"PHARUS_OIDC_TOKEN_URL\"),\n                    data=body,\n                    headers=headers,\n                    auth=auth,\n                )\n                auth_info = dict(\n                    jwt=result.json()[\"access_token\"], id=result.json()[\"id_token\"]\n                )\n                time.sleep(1)\n                connect_creds = {\n                    \"databaseAddress\": request.args[\"database_host\"],\n                    \"username\": jwt.decode(\n                        auth_info[\"jwt\"],\n                        crypto_serialization.load_der_public_key(\n                            b64decode(environ.get(\"PHARUS_OIDC_PUBLIC_KEY\").encode())\n                        ),\n                        algorithms=\"RS256\",\n                        options=dict(verify_aud=False),\n                    )[environ.get(\"PHARUS_OIDC_SUBJECT_KEY\")],\n                    \"password\": auth_info[\"jwt\"],\n                }\n            else:  # Database login\n                # Generate JWT key and send it back\n                auth_info = dict(\n                    jwt=jwt.encode(\n                        request.json, environ[\"PHARUS_PRIVATE_KEY\"], algorithm=\"RS256\"\n                    )\n                )\n                connect_creds = request.json\n            if connect_creds.keys() &lt; {\"databaseAddress\", \"username\", \"password\"}:\n                return dict(error=\"Invalid Request, check headers and/or json body\")\n            try:\n                dj.Connection(\n                    host=connect_creds[\"databaseAddress\"],\n                    user=connect_creds[\"username\"],\n                    password=connect_creds[\"password\"],\n                )\n            except pymysql.err.OperationalError as e:\n                if (\n                    (root_host := environ.get(\"DJ_HOST\"))\n                    and (root_user := environ.get(\"DJ_ROOT_USER\"))\n                    and (root_password := environ.get(\"DJ_ROOT_PASS\"))\n                ):\n                    dj.Connection(\n                        host=root_host,\n                        user=root_user,\n                        password=root_password,\n                    ).query(\"FLUSH PRIVILEGES\")\n                    dj.Connection(\n                        host=connect_creds[\"databaseAddress\"],\n                        user=connect_creds[\"username\"],\n                        password=connect_creds[\"password\"],\n                    )\n                else:\n                    raise e\n            return dict(**auth_info)\n        except Exception:\n            return traceback.format_exc(), 500\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.schema", "title": "<code>schema(connection)</code>", "text": "<p>Handler for <code>/schema</code> route.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <p>Returns:</p> Type Description <code>dict</code> <p>If successful, then sends back a list of schema names; otherwise, returns an error.</p>"}, {"location": "api/pharus/server/#pharus.server.schema--get-schema", "title": "GET /schema", "text": "<p>Route to get a list of schemas.</p>"}, {"location": "api/pharus/server/#pharus.server.schema--example-request", "title": "Example request:", "text": "<pre><code>GET /schema HTTP/1.1\nHost: fakeservices.datajoint.io\nAuthorization: Bearer &lt;token&gt;\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.schema--example-successful-response", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: application/json\n\n{\n\"schemaNames\": [\n\"alpha_company\"\n]\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.schema--example-unexpected-response", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could not\n    understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.schema--request-headers", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.schema--response-headers", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain, application/json</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.schema--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered.     Returns the error message as a string.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(f\"{environ.get('PHARUS_PREFIX', '')}/schema\", methods=[\"GET\"])\n@protected_route\ndef schema(connection: dj.Connection) -&gt; dict:\n\"\"\"\n    Handler for ``/schema`` route.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n\n    Returns:\n        If successful, then sends back a list of schema names; otherwise, returns an error.\n\n    ## GET /schema\n\n    Route to get a list of schemas.\n\n    ### Example request:\n\n    ```http\n    GET /schema HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Authorization: Bearer &lt;token&gt;\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"schemaNames\": [\n            \"alpha_company\"\n        ]\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could not\n        understand.\n    ```\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain, application/json\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered.\n        Returns the error message as a string.\n    \"\"\"\n\n    if request.method in {\"GET\", \"HEAD\"}:\n        # Get all the schemas\n        try:\n            schemas_name = _DJConnector._list_schemas(connection)\n            return dict(schemaNames=schemas_name)\n        except Exception:\n            return traceback.format_exc(), 500\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.table", "title": "<code>table(connection, schema_name)</code>", "text": "<p>Handler for <code>/schema/{schema_name}/table</code> route.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <code>schema_name</code> <code>str</code> <p>Schema name.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>If successful, then sends back a list of table names; otherwise, returns an error.</p>"}, {"location": "api/pharus/server/#pharus.server.table--get-schemaschema_nametable", "title": "GET /schema/{schema_name}/table", "text": "<p>Route to get tables within a schema.</p>"}, {"location": "api/pharus/server/#pharus.server.table--example-request", "title": "Example request:", "text": "<pre><code>GET /schema/alpha_company/table HTTP/1.1\nHost: fakeservices.datajoint.io\nAuthorization: Bearer &lt;token&gt;\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.table--example-successful-response", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: application/json\n\n{\n\"tableTypes\": {\n\"computed\": [],\n\"imported\": [],\n\"lookup\": [\n\"Employee\"\n],\n\"manual\": [\n\"Computer\"\n],\n\"part\": []\n}\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.table--example-unexpected-response", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could not\n    understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.table--query-parameters", "title": "Query Parameters", "text": "<ul> <li>schema_name: Schema name.</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.table--request-headers", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.table--response-headers", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain, application/json</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.table--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered.     Returns the error message as a string.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(\n    f\"{environ.get('PHARUS_PREFIX', '')}/schema/&lt;schema_name&gt;/table\", methods=[\"GET\"]\n)\n@protected_route\ndef table(\n    connection: dj.Connection,\n    schema_name: str,\n) -&gt; dict:\n\"\"\"\n    Handler for ``/schema/{schema_name}/table`` route.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n        schema_name (str): Schema name.\n\n    Returns:\n        If successful, then sends back a list of table names; otherwise, returns an error.\n\n    ## GET /schema/{schema_name}/table\n\n    Route to get tables within a schema.\n\n    ### Example request:\n\n    ```http\n    GET /schema/alpha_company/table HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Authorization: Bearer &lt;token&gt;\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"tableTypes\": {\n            \"computed\": [],\n            \"imported\": [],\n            \"lookup\": [\n                \"Employee\"\n            ],\n            \"manual\": [\n                \"Computer\"\n            ],\n            \"part\": []\n        }\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could not\n        understand.\n    ```\n\n    #### Query Parameters\n    * schema_name: Schema name.\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain, application/json\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered.\n        Returns the error message as a string.\n    \"\"\"\n    if request.method in {\"GET\", \"HEAD\"}:\n        try:\n            tables_dict_list = _DJConnector._list_tables(connection, schema_name)\n            return dict(tableTypes=tables_dict_list)\n        except Exception:\n            return traceback.format_exc(), 500\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record", "title": "<code>record(connection, schema_name, table_name)</code>", "text": "<p>Handler for <code>/schema/{schema_name}/table/{table_name}/record</code> route.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <code>schema_name</code> <code>str</code> <p>Schema name.</p> required <code>table_name</code> <code>str</code> <p>Table name.</p> required <p>Returns:</p> Type Description <code>Union[dict, str, tuple]</code> <p>If successful, then sends back the desired operation based on the HTTP method; otherwise, returns an error.</p>"}, {"location": "api/pharus/server/#pharus.server.record--get-schemaschema_nametabletable_namerecord", "title": "GET /schema/{schema_name}/table/{table_name}/record", "text": "<p>Route to fetch records.</p>"}, {"location": "api/pharus/server/#pharus.server.record--example-request", "title": "Example request:", "text": "<pre><code>GET /schema/alpha_company/table/Computer/record?limit=1&amp;page=2&amp;order=computer_id%20DESC&amp;\n    restriction=W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49I\n    iwgInZhbHVlIjogMTZ9XQo= HTTP/1.1\nHost: fakeservices.datajoint.io\nAuthorization: Bearer &lt;token&gt;\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-successful-response", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: application/json\n\n{\n\"recordHeader\": [\n\"computer_id\",\n\"computer_serial\",\n\"computer_brand\",\n\"computer_built\",\n\"computer_processor\",\n\"computer_memory\",\n\"computer_weight\",\n\"computer_cost\",\n\"computer_preowned\",\n\"computer_purchased\",\n\"computer_updates\",\n\"computer_accessories\"\n],\n\"records\": [\n[\n\"4e41491a-86d5-4af7-a013-89bde75528bd\",\n\"DJS1JA17G\",\n\"Dell\",\n1590364800,\n2.2,\n16,\n4.4,\n\"700.99\",\n0,\n1603181061,\nnull,\n\"=BLOB=\"\n]\n],\n\"totalCount\": 2\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-unexpected-response", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could\n    not understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--query-parameters", "title": "Query Parameters", "text": "<ul> <li>schema_name: Schema name.</li> <li>table_name: Table name.</li> <li>limit: Limit of how many records per page. Defaults to <code>1000</code>.</li> <li>page: Page requested. Defaults to <code>1</code>.</li> <li>order: Sort order. Defaults to <code>KEY ASC</code>.</li> <li>restriction: Base64-encoded <code>AND</code> sequence of restrictions. For example, you could     restrict as <code>[{\"attributeName\": \"computer_memory\", \"operation\": \"&gt;=\", \"value\": 16}]</code>     with this param set as <code>W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0a     W9uIjogIj49IiwgInZhbHVlIjogMTZ9XQo=</code>. Defaults to no restriction.</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--request-headers", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--response-headers", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain, application/json</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered. Returns the error message as a     string.</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--post-schemaschema_nametabletable_namerecord", "title": "POST /schema/{schema_name}/table/{table_name}/record", "text": "<p>Route to insert a record. Omitted attributes utilize the default if set.</p>"}, {"location": "api/pharus/server/#pharus.server.record--example-request_1", "title": "Example request:", "text": "<pre><code>POST /schema/alpha_company/table/Computer/record HTTP/1.1\nHost: fakeservices.datajoint.io\nAccept: application/json\nAuthorization: Bearer &lt;token&gt;\n\n{\n    \"records\": [\n        {\n            \"computer_id\": \"ffffffff-86d5-4af7-a013-89bde75528bd\",\n            \"computer_serial\": \"ZYXWVEISJ\",\n            \"computer_brand\": \"HP\",\n            \"computer_built\": \"2021-01-01\",\n            \"computer_processor\": 2.7,\n            \"computer_memory\": 32,\n            \"computer_weight\": 3.7,\n            \"computer_cost\": 599.99,\n            \"computer_preowned\": 0,\n            \"computer_purchased\": \"2021-02-01 13:00:00\",\n            \"computer_updates\": 0\n        }\n    ]\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-successful-response_1", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: text/plain\n\n{\n    \"response\": \"Insert Successful\"\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-unexpected-response_1", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could\n    not understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--request-headers_1", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--response-headers_1", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--status-codes_1", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered. Returns the error message as a     string.</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--patch-schemaschema_nametabletable_namerecord", "title": "PATCH /schema/{schema_name}/table/{table_name}/record", "text": "<p>Route to update a record. Omitted attributes utilize the default if set.</p>"}, {"location": "api/pharus/server/#pharus.server.record--example-request_2", "title": "Example request:", "text": "<pre><code>PATCH /schema/alpha_company/table/Computer/record HTTP/1.1\nHost: fakeservices.datajoint.io\nAccept: application/json\nAuthorization: Bearer &lt;token&gt;\n\n{\n    \"records\": [\n        {\n            \"computer_id\": \"ffffffff-86d5-4af7-a013-89bde75528bd\",\n            \"computer_serial\": \"ZYXWVEISJ\",\n            \"computer_brand\": \"HP\",\n            \"computer_built\": \"2021-01-01\",\n            \"computer_processor\": 2.7,\n            \"computer_memory\": 32,\n            \"computer_weight\": 3.7,\n            \"computer_cost\": 601.01,\n            \"computer_preowned\": 0,\n            \"computer_purchased\": \"2021-02-01 13:00:00\",\n            \"computer_updates\": 0\n        }\n    ]\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-successful-response_2", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: text/plain\n\n{\n    \"response\": \"Update Successful\"\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-unexpected-response_2", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could\n    not understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--request-headers_2", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--response-headers_2", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--status-codes_2", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered. Returns the error message as a     string.</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--delete-schemaschema_nametabletable_namerecord", "title": "DELETE /schema/{schema_name}/table/{table_name}/record", "text": "<p>Route to delete a specific record.</p>"}, {"location": "api/pharus/server/#pharus.server.record--example-request_3", "title": "Example request:", "text": "<pre><code>DELETE /schema/alpha_company/table/Computer/record?cascade=false&amp;restriction=\n    W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49IiwgInZhbHVlI\n    jogMTZ9XQo= HTTP/1.1\nHost: fakeservices.datajoint.io\nAuthorization: Bearer &lt;token&gt;\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-successful-response_3", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: text/plain\n\n{\n    \"response\": \"Delete Successful\"\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-conflict-response", "title": "Example conflict response:", "text": "<pre><code>HTTP/1.1 409 Conflict\nVary: Accept\nContent-Type: application/json\n\n{\n\"error\": \"IntegrityError\",\n\"error_msg\": \"Cannot delete or update a parent row: a foreign key\n        constraint fails (`alpha_company`.`#employee`, CONSTRAINT\n        `#employee_ibfk_1` FOREIGN KEY (`computer_id`) REFERENCES `computer`\n        (`computer_id`) ON DELETE RESTRICT ON UPDATE CASCADE\",\n\"child_schema\": \"alpha_company\",\n\"child_table\": \"Employee\"\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--example-unexpected-response_3", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could\n    not understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.record--query-parameters_1", "title": "Query Parameters", "text": "<ul> <li>cascade: Enable cascading delete. Accepts <code>true</code> or <code>false</code>. Defaults to     <code>false</code>.</li> <li>restriction: Base64-encoded <code>AND</code> sequence of restrictions. For example,     you could restrict as <code>[{\"attributeName\": \"computer_memory\", \"operation\": \"&gt;=\",     \"value\": 16}]</code> with this param set as     <code>W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49     IiwgInZhbHVlIjogMTZ9XQo=</code>. Defaults to no restriction.</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--request-headers_3", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--response-headers_3", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain, application/json</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.record--status-codes_3", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>409 Conflict: Attempting to delete a record with dependents while <code>cascade</code>     set to <code>false</code>.</li> <li>500 Internal Server Error: Unexpected error encountered. Returns the error message as a     string.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(\n    f\"{environ.get('PHARUS_PREFIX', '')}/schema/&lt;schema_name&gt;/table/&lt;table_name&gt;/record\",\n    methods=[\"GET\", \"POST\", \"PATCH\", \"DELETE\"],\n)\n@protected_route\ndef record(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n) -&gt; Union[dict, str, tuple]:\n    (\n\"\"\"\n    Handler for ``/schema/{schema_name}/table/{table_name}/record`` route.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n        schema_name (str): Schema name.\n        table_name (str): Table name.\n\n    Returns:\n        If successful, then sends back the desired operation based on the HTTP method;\n            otherwise, returns an error.\n\n    ## GET /schema/{schema_name}/table/{table_name}/record\n\n    Route to fetch records.\n\n    ### Example request:\n\n    ```http\n    GET /schema/alpha_company/table/Computer/record?limit=1&amp;page=2&amp;order=computer_id%20DESC&amp;\n        restriction=W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49I\n        iwgInZhbHVlIjogMTZ9XQo= HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Authorization: Bearer &lt;token&gt;\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"recordHeader\": [\n            \"computer_id\",\n            \"computer_serial\",\n            \"computer_brand\",\n            \"computer_built\",\n            \"computer_processor\",\n            \"computer_memory\",\n            \"computer_weight\",\n            \"computer_cost\",\n            \"computer_preowned\",\n            \"computer_purchased\",\n            \"computer_updates\",\n            \"computer_accessories\"\n        ],\n        \"records\": [\n            [\n                \"4e41491a-86d5-4af7-a013-89bde75528bd\",\n                \"DJS1JA17G\",\n                \"Dell\",\n                1590364800,\n                2.2,\n                16,\n                4.4,\n                \"700.99\",\n                0,\n                1603181061,\n                null,\n                \"=BLOB=\"\n            ]\n        ],\n        \"totalCount\": 2\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could\n        not understand.\n    ```\n\n    #### Query Parameters\n    * schema_name: Schema name.\n    * table_name: Table name.\n    * limit: Limit of how many records per page. Defaults to `1000`.\n    * page: Page requested. Defaults to `1`.\n    * order: Sort order. Defaults to `KEY ASC`.\n    * restriction: Base64-encoded `AND` sequence of restrictions. For example, you could\n        restrict as `[{\"attributeName\": \"computer_memory\", \"operation\": \"&gt;=\", \"value\": 16}]`\n        with this param set as `W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0a\n        W9uIjogIj49IiwgInZhbHVlIjogMTZ9XQo=`. Defaults to no restriction.\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain, application/json\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered. Returns the error message as a\n        string.\n\n    ## POST /schema/{schema_name}/table/{table_name}/record\n\n    Route to insert a record. Omitted attributes utilize the default if set.\n\n    ### Example request:\n\n    ```http\n    POST /schema/alpha_company/table/Computer/record HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Accept: application/json\n    Authorization: Bearer &lt;token&gt;\n\n    {\n        \"records\": [\n            {\n                \"computer_id\": \"ffffffff-86d5-4af7-a013-89bde75528bd\",\n                \"computer_serial\": \"ZYXWVEISJ\",\n                \"computer_brand\": \"HP\",\n                \"computer_built\": \"2021-01-01\",\n                \"computer_processor\": 2.7,\n                \"computer_memory\": 32,\n                \"computer_weight\": 3.7,\n                \"computer_cost\": 599.99,\n                \"computer_preowned\": 0,\n                \"computer_purchased\": \"2021-02-01 13:00:00\",\n                \"computer_updates\": 0\n            }\n        ]\n    }\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: text/plain\n\n    {\n        \"response\": \"Insert Successful\"\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could\n        not understand.\n    ```\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered. Returns the error message as a\n        string.\n\n    ## PATCH /schema/{schema_name}/table/{table_name}/record\n\n    Route to update a record. Omitted attributes utilize the default if set.\n\n    ### Example request:\n\n    ```http\n    PATCH /schema/alpha_company/table/Computer/record HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Accept: application/json\n    Authorization: Bearer &lt;token&gt;\n\n    {\n        \"records\": [\n            {\n                \"computer_id\": \"ffffffff-86d5-4af7-a013-89bde75528bd\",\n                \"computer_serial\": \"ZYXWVEISJ\",\n                \"computer_brand\": \"HP\",\n                \"computer_built\": \"2021-01-01\",\n                \"computer_processor\": 2.7,\n                \"computer_memory\": 32,\n                \"computer_weight\": 3.7,\n                \"computer_cost\": 601.01,\n                \"computer_preowned\": 0,\n                \"computer_purchased\": \"2021-02-01 13:00:00\",\n                \"computer_updates\": 0\n            }\n        ]\n    }\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: text/plain\n\n    {\n        \"response\": \"Update Successful\"\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could\n        not understand.\n    ```\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered. Returns the error message as a\n        string.\n\n    ## DELETE /schema/{schema_name}/table/{table_name}/record\n\n    Route to delete a specific record.\n\n    ### Example request:\n\n    ```http\n    DELETE /schema/alpha_company/table/Computer/record?cascade=false&amp;restriction=\n        W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49IiwgInZhbHVlI\n        jogMTZ9XQo= HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Authorization: Bearer &lt;token&gt;\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: text/plain\n\n    {\n        \"response\": \"Delete Successful\"\n    }\n    ```\n\n    ### Example conflict response:\n\n    ```http\n    HTTP/1.1 409 Conflict\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"error\": \"IntegrityError\",\n        \"error_msg\": \"Cannot delete or update a parent row: a foreign key\n            constraint fails (`alpha_company`.`#employee`, CONSTRAINT\n            `#employee_ibfk_1` FOREIGN KEY (`computer_id`) REFERENCES `computer`\n            (`computer_id`) ON DELETE RESTRICT ON UPDATE CASCADE\",\n        \"child_schema\": \"alpha_company\",\n        \"child_table\": \"Employee\"\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could\n        not understand.\n    ```\n\n    #### Query Parameters\n    * cascade: Enable cascading delete. Accepts ``true`` or ``false``. Defaults to\n        ``false``.\n    * restriction: Base64-encoded ``AND`` sequence of restrictions. For example,\n        you could restrict as ``[{\"attributeName\": \"computer_memory\", \"operation\": \"&gt;=\",\n        \"value\": 16}]`` with this param set as\n        ``W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49\n        IiwgInZhbHVlIjogMTZ9XQo=``. Defaults to no restriction.\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain, application/json\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 409 Conflict: Attempting to delete a record with dependents while ``cascade``\n        set to ``false``.\n    * 500 Internal Server Error: Unexpected error encountered. Returns the error message as a\n        string.\n\n    \"\"\"\n    )\n    if request.method in {\"GET\", \"HEAD\"}:\n        try:\n            schema_virtual_module = dj.VirtualModule(\n                schema_name, schema_name, connection=connection\n            )\n\n            # Get table object from name\n            dj_table = _DJConnector._get_table_object(schema_virtual_module, table_name)\n\n            record_header, table_tuples, total_count = _DJConnector._fetch_records(\n                query=dj_table,\n                **{\n                    k: int(v) for k, v in request.args.items() if k in (\"limit\", \"page\")\n                },\n                **{\n                    k: loads(b64decode(v.encode(\"utf-8\")).decode(\"utf-8\"))\n                    for k, v in request.args.items()\n                    if k == \"restriction\"\n                },\n                **{k: v.split(\",\") for k, v in request.args.items() if k == \"order\"},\n            )\n            return dict(\n                recordHeader=record_header, records=table_tuples, totalCount=total_count\n            )\n        except Exception:\n            return traceback.format_exc(), 500\n    elif request.method == \"POST\":\n        try:\n            _DJConnector._insert_tuple(\n                connection, schema_name, table_name, request.json[\"records\"]\n            )\n            return {\"response\": \"Insert Successful\"}\n        except Exception:\n            return traceback.format_exc(), 500\n    elif request.method == \"PATCH\":\n        try:\n            _DJConnector._update_tuple(\n                connection, schema_name, table_name, request.json[\"records\"]\n            )\n            return {\"response\": \"Update Successful\"}\n        except Exception:\n            return traceback.format_exc(), 500\n    elif request.method == \"DELETE\":\n        try:\n            _DJConnector._delete_records(\n                connection,\n                schema_name,\n                table_name,\n                **{\n                    k: loads(b64decode(v.encode(\"utf-8\")).decode(\"utf-8\"))\n                    for k, v in request.args.items()\n                    if k == \"restriction\"\n                },\n                **{\n                    k: v.lower() == \"true\"\n                    for k, v in request.args.items()\n                    if k == \"cascade\"\n                },\n            )\n            return {\"response\": \"Delete Successful\"}\n        except IntegrityError as e:\n            match = foreign_key_error_regexp.match(e.args[0])\n            return (\n                dict(\n                    error=e.__class__.__name__,\n                    errorMessage=str(e),\n                    childSchema=match.group(\"child\").split(\".\")[0][1:-1],\n                    childTable=to_camel_case(match.group(\"child\").split(\".\")[1][1:-1]),\n                ),\n                409,\n            )\n        except Exception:\n            return traceback.format_exc(), 500\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.definition", "title": "<code>definition(connection, schema_name, table_name)</code>", "text": "<p>Handler for <code>/schema/{schema_name}/table/{table_name}/definition</code> route.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <code>schema_name</code> <code>str</code> <p>Schema name.</p> required <code>table_name</code> <code>str</code> <p>Table name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>If successful, then sends back the definition for the table; otherwise, returns an error.</p>"}, {"location": "api/pharus/server/#pharus.server.definition--get-schemaschema_nametabletable_namedefinition", "title": "GET /schema/{schema_name}/table/{table_name}/definition", "text": "<p>Route to get DataJoint table definition.</p>"}, {"location": "api/pharus/server/#pharus.server.definition--example-request", "title": "Example request:", "text": "<pre><code>GET /schema/alpha_company/table/Computer/definition HTTP/1.1\nHost: fakeservices.datajoint.io\nAuthorization: Bearer &lt;token&gt;\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.definition--example-successful-response", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: text/plain\n\n# Computers that belong to the company\ncomputer_id          : uuid                      # unique id\n---\ncomputer_serial=\"ABC101\" : varchar(9)            # manufacturer serial number\ncomputer_brand       : enum('HP','Dell')         # manufacturer brand\ncomputer_built       : date                      # manufactured date\ncomputer_processor   : double                    # processing power in GHz\ncomputer_memory      : int                       # RAM in GB\ncomputer_weight      : float                     # weight in lbs\ncomputer_cost        : decimal(6,2)              # purchased price\ncomputer_preowned    : tinyint                   # purchased as new or used\ncomputer_purchased   : datetime                  # purchased date and time\ncomputer_updates=null : time                     # scheduled daily update timeslot\ncomputer_accessories=null : longblob             # included additional accessories\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.definition--example-unexpected-response", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could not\n    understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.definition--request-headers", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.definition--response-headers", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.definition--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered. Returns the error message as a     string.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(\n    f\"{environ.get('PHARUS_PREFIX', '')}/schema/&lt;schema_name&gt;/table/&lt;table_name&gt;/definition\",\n    methods=[\"GET\"],\n)\n@protected_route\ndef definition(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n) -&gt; str:\n\"\"\"\n    Handler for ``/schema/{schema_name}/table/{table_name}/definition`` route.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n        schema_name (str): Schema name.\n        table_name (str): Table name.\n\n    Returns:\n        If successful, then sends back the definition for the table; otherwise,\n            returns an error.\n\n    ## GET /schema/{schema_name}/table/{table_name}/definition\n\n    Route to get DataJoint table definition.\n\n    ### Example request:\n\n    ```http\n    GET /schema/alpha_company/table/Computer/definition HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Authorization: Bearer &lt;token&gt;\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: text/plain\n\n    # Computers that belong to the company\n    computer_id          : uuid                      # unique id\n    ---\n    computer_serial=\"ABC101\" : varchar(9)            # manufacturer serial number\n    computer_brand       : enum('HP','Dell')         # manufacturer brand\n    computer_built       : date                      # manufactured date\n    computer_processor   : double                    # processing power in GHz\n    computer_memory      : int                       # RAM in GB\n    computer_weight      : float                     # weight in lbs\n    computer_cost        : decimal(6,2)              # purchased price\n    computer_preowned    : tinyint                   # purchased as new or used\n    computer_purchased   : datetime                  # purchased date and time\n    computer_updates=null : time                     # scheduled daily update timeslot\n    computer_accessories=null : longblob             # included additional accessories\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could not\n        understand.\n    ```\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered. Returns the error message as a\n        string.\n    \"\"\"\n\n    if request.method in {\"GET\", \"HEAD\"}:\n        try:\n            table_definition = _DJConnector._get_table_definition(\n                connection, schema_name, table_name\n            )\n            return table_definition\n        except Exception:\n            return traceback.format_exc(), 500\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.attribute", "title": "<code>attribute(connection, schema_name, table_name)</code>", "text": "<p>Handler for <code>/schema/{schema_name}/table/{table_name}/attribute</code> route.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <code>schema_name</code> <code>str</code> <p>Schema name.</p> required <code>table_name</code> <code>str</code> <p>Table name.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>If successful, then sends back a dictionary of table attributes; otherwise, returns an error.</p>"}, {"location": "api/pharus/server/#pharus.server.attribute--get-schemaschema_nametabletable_nameattribute", "title": "GET /schema/{schema_name}/table/{table_name}/attribute", "text": "<p>Route to get metadata on table attributes.</p>"}, {"location": "api/pharus/server/#pharus.server.attribute--example-request", "title": "Example request:", "text": "<pre><code>GET /schema/alpha_company/table/Computer/attribute HTTP/1.1\nHost: fakeservices.datajoint.io\nAuthorization: Bearer &lt;token&gt;\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.attribute--example-successful-response", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: application/json\n\n{\n\"attributeHeader\": [\n\"name\",\n\"type\",\n\"nullable\",\n\"default\",\n\"autoincrement\"\n],\n\"attributes\": {\n\"primary\": [\n[\n\"computer_id\",\n\"uuid\",\nfalse,\nnull,\nfalse\n]\n],\n\"secondary\": [\n[\n\"computer_serial\",\n\"varchar(9)\",\nfalse,\n\"\"ABC101\"\",\nfalse\n],\n[\n\"computer_brand\",\n\"enum('HP','Dell')\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_built\",\n\"date\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_processor\",\n\"double\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_memory\",\n\"int\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_weight\",\n\"float\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_cost\",\n\"decimal(6,2)\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_preowned\",\n\"tinyint\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_purchased\",\n\"datetime\",\nfalse,\nnull,\nfalse\n],\n[\n\"computer_updates\",\n\"time\",\ntrue,\n\"null\",\nfalse\n],\n[\n\"computer_accessories\",\n\"longblob\",\ntrue,\n\"null\",\nfalse\n]\n]\n}\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.attribute--example-unexpected-response", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could not\n    understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.attribute--request-headers", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.attribute--response-headers", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain, application/json</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.attribute--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered. Returns the error message as a     string.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(\n    f\"{environ.get('PHARUS_PREFIX', '')}/schema/&lt;schema_name&gt;/table/&lt;table_name&gt;/attribute\",\n    methods=[\"GET\"],\n)\n@protected_route\ndef attribute(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n) -&gt; dict:\n\"\"\"\n    Handler for ``/schema/{schema_name}/table/{table_name}/attribute`` route.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n        schema_name (str): Schema name.\n        table_name (str): Table name.\n\n    Returns:\n        If successful, then sends back a dictionary of table attributes; otherwise,\n            returns an error.\n\n    ## GET /schema/{schema_name}/table/{table_name}/attribute\n\n    Route to get metadata on table attributes.\n\n    ### Example request:\n\n    ```http\n    GET /schema/alpha_company/table/Computer/attribute HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Authorization: Bearer &lt;token&gt;\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"attributeHeader\": [\n            \"name\",\n            \"type\",\n            \"nullable\",\n            \"default\",\n            \"autoincrement\"\n        ],\n        \"attributes\": {\n            \"primary\": [\n                [\n                    \"computer_id\",\n                    \"uuid\",\n                    false,\n                    null,\n                    false\n                ]\n            ],\n            \"secondary\": [\n                [\n                    \"computer_serial\",\n                    \"varchar(9)\",\n                    false,\n                    \"\"ABC101\"\",\n                    false\n                ],\n                [\n                    \"computer_brand\",\n                    \"enum('HP','Dell')\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_built\",\n                    \"date\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_processor\",\n                    \"double\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_memory\",\n                    \"int\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_weight\",\n                    \"float\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_cost\",\n                    \"decimal(6,2)\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_preowned\",\n                    \"tinyint\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_purchased\",\n                    \"datetime\",\n                    false,\n                    null,\n                    false\n                ],\n                [\n                    \"computer_updates\",\n                    \"time\",\n                    true,\n                    \"null\",\n                    false\n                ],\n                [\n                    \"computer_accessories\",\n                    \"longblob\",\n                    true,\n                    \"null\",\n                    false\n                ]\n            ]\n        }\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could not\n        understand.\n    ```\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain, application/json\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered. Returns the error message as a\n        string.\n    \"\"\"\n\n    if request.method in {\"GET\", \"HEAD\"}:\n        try:\n            local_values = locals()\n            local_values[schema_name] = dj.VirtualModule(\n                schema_name, schema_name, connection=connection\n            )\n\n            # Get table object from name\n            dj_table = _DJConnector._get_table_object(\n                local_values[schema_name], table_name\n            )\n\n            attributes_meta = _DJConnector._get_attributes(dj_table)\n            return dict(\n                attributeHeaders=attributes_meta[\"attribute_headers\"],\n                attributes=attributes_meta[\"attributes\"],\n            )\n        except Exception:\n            return traceback.format_exc(), 500\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.dependency", "title": "<code>dependency(connection, schema_name, table_name)</code>", "text": "<p>Handler for <code>/schema/{schema_name}/table/{table_name}/dependency</code> route.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>User's DataJoint connection object</p> required <code>schema_name</code> <code>str</code> <p>Schema name.</p> required <code>table_name</code> <code>str</code> <p>Table name.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>If successful, then sends back a list of dependencies; otherwise, returns an error.</p>"}, {"location": "api/pharus/server/#pharus.server.dependency--get-schemaschema_nametabletable_namedependency", "title": "GET /schema/{schema_name}/table/{table_name}/dependency", "text": "<p>Route to get the metadata in relation to the dependent records associated with a     restricted subset of a table.</p>"}, {"location": "api/pharus/server/#pharus.server.dependency--example-request", "title": "Example request:", "text": "<pre><code>GET /schema/alpha_company/table/Computer/dependency?restriction=\n    W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49IiwgInZ=\n    HTTP/1.1\nHost: fakeservices.datajoint.io\nAuthorization: Bearer &lt;token&gt;\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.dependency--example-successful-response", "title": "Example successful response:", "text": "<pre><code>HTTP/1.1 200 OK\nVary: Accept\nContent-Type: application/json\n\n{\n\"dependencies\": [\n{\n\"accessible\": true,\n\"count\": 2,\n\"schema\": \"alpha_company\",\n\"table\": \"computer\"\n},\n{\n\"accessible\": true,\n\"count\": 2,\n\"schema\": \"alpha_company\",\n\"table\": \"#employee\"\n}\n]\n}\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.dependency--example-unexpected-response", "title": "Example unexpected response:", "text": "<pre><code>HTTP/1.1 500 Internal Server Error\nVary: Accept\nContent-Type: text/plain\n\n400 Bad Request: The browser (or proxy) sent a request that this server could not\n    understand.\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.dependency--query-parameters", "title": "Query Parameters", "text": "<ul> <li>schema_name: Schema name.</li> <li>table_name: Table name.</li> <li>restriction: Base64-encoded <code>AND</code> sequence of restrictions. For example, you could     restrict as <code>[{\"attributeName\": \"computer_memory\", \"operation\": \"&gt;=\", \"value\": 16}]</code>     with this param set as     <code>W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49IiwgInZ=</code>.     Defaults to no restriction.</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.dependency--request-headers", "title": "Request Headers", "text": "<ul> <li>Authorization: Bearer &lt;OAuth2_token&gt;</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.dependency--response-headers", "title": "Response Headers", "text": "<ul> <li>Content-Type: text/plain, application/json</li> </ul>"}, {"location": "api/pharus/server/#pharus.server.dependency--status-codes", "title": "Status Codes", "text": "<ul> <li>200 OK: No error.</li> <li>500 Internal Server Error: Unexpected error encountered. Returns the error message as a     string.</li> </ul> Source code in <code>pharus/server.py</code> <pre><code>@app.route(\n    f\"{environ.get('PHARUS_PREFIX', '')}/schema/&lt;schema_name&gt;/table/&lt;table_name&gt;/dependency\",\n    methods=[\"GET\"],\n)\n@protected_route\ndef dependency(\n    connection: dj.Connection,\n    schema_name: str,\n    table_name: str,\n) -&gt; dict:\n    (\n\"\"\"\n    Handler for ``/schema/{schema_name}/table/{table_name}/dependency`` route.\n\n    Args:\n        connection (dj.Connection): User's DataJoint connection object\n        schema_name (str): Schema name.\n        table_name (str): Table name.\n\n    Returns:\n        If successful, then sends back a list of dependencies; otherwise, returns an error.\n\n    ## GET /schema/{schema_name}/table/{table_name}/dependency\n\n    Route to get the metadata in relation to the dependent records associated with a\n        restricted subset of a table.\n\n    ### Example request:\n\n    ```http\n    GET /schema/alpha_company/table/Computer/dependency?restriction=\n        W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49IiwgInZ=\n        HTTP/1.1\n    Host: fakeservices.datajoint.io\n    Authorization: Bearer &lt;token&gt;\n    ```\n\n    ### Example successful response:\n\n    ```http\n    HTTP/1.1 200 OK\n    Vary: Accept\n    Content-Type: application/json\n\n    {\n        \"dependencies\": [\n            {\n                \"accessible\": true,\n                \"count\": 2,\n                \"schema\": \"alpha_company\",\n                \"table\": \"computer\"\n            },\n            {\n                \"accessible\": true,\n                \"count\": 2,\n                \"schema\": \"alpha_company\",\n                \"table\": \"#employee\"\n            }\n        ]\n    }\n    ```\n\n    ### Example unexpected response:\n\n    ```http\n    HTTP/1.1 500 Internal Server Error\n    Vary: Accept\n    Content-Type: text/plain\n\n    400 Bad Request: The browser (or proxy) sent a request that this server could not\n        understand.\n    ```\n\n    #### Query Parameters\n    * schema_name: Schema name.\n    * table_name: Table name.\n    * restriction: Base64-encoded ``AND`` sequence of restrictions. For example, you could\n        restrict as ``[{\"attributeName\": \"computer_memory\", \"operation\": \"&gt;=\", \"value\": 16}]``\n        with this param set as\n        ``W3siYXR0cmlidXRlTmFtZSI6ICJjb21wdXRlcl9tZW1vcnkiLCAib3BlcmF0aW9uIjogIj49IiwgInZ=``.\n        Defaults to no restriction.\n\n    #### Request Headers\n    * Authorization: Bearer &lt;OAuth2_token\\&gt;\n\n    #### Response Headers\n    * Content-Type: text/plain, application/json\n\n    #### Status Codes\n    * 200 OK: No error.\n    * 500 Internal Server Error: Unexpected error encountered. Returns the error message as a\n        string.\n    \"\"\"\n    )\n    if request.method in {\"GET\", \"HEAD\"}:\n        # Get dependencies\n        try:\n            dependencies = _DJConnector._record_dependency(\n                connection,\n                schema_name,\n                table_name,\n                loads(\n                    b64decode(request.args.get(\"restriction\").encode(\"utf-8\")).decode(\n                        \"utf-8\"\n                    )\n                ),\n            )\n            return dict(dependencies=dependencies)\n        except Exception:\n            return traceback.format_exc(), 500\n</code></pre>"}, {"location": "api/pharus/server/#pharus.server.run", "title": "<code>run()</code>", "text": "<p>Starts API server.</p> Source code in <code>pharus/server.py</code> <pre><code>def run():\n\"\"\"\n    Starts API server.\n    \"\"\"\n    app.run(host=\"0.0.0.0\", port=environ.get(\"PHARUS_PORT\", 5000), threaded=False)\n</code></pre>"}]}